import {
  __commonJS,
  __require
} from "./chunk-WNKWOKNR.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-wordnet/lib/wordnet_file.js
var require_wordnet_file = __commonJS({
  "node_modules/node-wordnet/lib/wordnet_file.js"(exports2, module2) {
    var WordNetFile;
    var fs;
    var path;
    var util;
    fs = require_fs();
    path = require_path();
    util = require_util();
    module2.exports = WordNetFile = function() {
      function WordNetFile2(dataDir, fileName) {
        this.dataDir = dataDir;
        this.fileName = fileName;
        this.filePath = path.join(this.dataDir, this.fileName);
      }
      WordNetFile2.prototype.open = function(callback) {
        var filePath, self2;
        self2 = this;
        if (this.fd) {
          return callback.call(self2, null, this.fd);
        }
        filePath = this.filePath;
        return fs.open(filePath, "r", null, function(_this) {
          return function(err, fd) {
            if (err != null) {
              return callback.call(self2, err, null);
            }
            _this.fd = fd;
            return callback.call(self2, err, fd);
          };
        }(this));
      };
      WordNetFile2.prototype.close = function() {
        if (this.fd != null) {
          fs.close(this.fd);
          return delete this.fd;
        }
      };
      WordNetFile2.prototype.appendLineChar = function(fd, pos, buffPos, buff, callback) {
        var length, self2, space;
        self2 = this;
        length = buff.length;
        space = length - buffPos;
        return fs.read(fd, buff, buffPos, space, pos, function(err, count, buffer) {
          var i, j, newBuff, ref;
          if (err != null) {
            return callback.call(self2, err, null);
          }
          for (i = j = 0, ref = count - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            if (buff[i] === 10) {
              return callback.call(self2, null, buff.slice(0, i).toString("ASCII"));
            }
          }
          newBuff = new Buffer(length * 2);
          buff.copy(newBuff, 0, 0, length);
          return self2.appendLineChar(fd, pos + length, length, newBuff, callback);
        });
      };
      return WordNetFile2;
    }();
  }
});

// node_modules/node-wordnet/lib/index_file.js
var require_index_file = __commonJS({
  "node_modules/node-wordnet/lib/index_file.js"(exports2, module2) {
    var IndexFile;
    var WordNetFile;
    var fs;
    var util;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    WordNetFile = require_wordnet_file();
    fs = require_fs();
    util = require_util();
    module2.exports = IndexFile = function(superClass) {
      var _findAt, _findPrevEOL, _getFileSize, _readLine;
      extend(IndexFile2, superClass);
      function IndexFile2(dataDir, name) {
        IndexFile2.__super__.constructor.call(this, dataDir, "index." + name);
      }
      _findPrevEOL = function(self2, fd, pos, callback) {
        var buff;
        buff = new Buffer(1024);
        if (pos === 0) {
          return callback(null, 0);
        } else {
          return fs.read(fd, buff, 0, 1, pos, function(err, count) {
            if (err != null) {
              return callback(err, count);
            }
            if (buff[0] === 10) {
              return callback(null, pos + 1);
            } else {
              return _findPrevEOL(self2, fd, pos - 1, callback);
            }
          });
        }
      };
      _readLine = function(self2, fd, pos, callback) {
        var buff;
        buff = new Buffer(1024);
        return _findPrevEOL(self2, fd, pos, function(err, pos2) {
          if (err != null) {
            return callback(err, pos2);
          }
          return self2.appendLineChar(fd, pos2, 0, buff, callback);
        });
      };
      _findAt = function(self2, fd, size, pos, lastPos, adjustment, searchKey, callback, lastKey) {
        if (lastPos === pos || pos >= size) {
          return callback(null, {
            status: "miss"
          });
        } else {
          return _readLine(self2, fd, pos, function(err, line) {
            var key, tokens;
            if (err != null) {
              return callback(err);
            }
            tokens = line.split(/\s+/);
            key = tokens[0];
            if (key === searchKey) {
              return callback(null, {
                status: "hit",
                key,
                "line": line,
                tokens
              });
            } else if (adjustment === 1 || key === lastKey) {
              return callback(null, {
                status: "miss"
              });
            } else {
              adjustment = Math.ceil(adjustment * 0.5);
              if (key < searchKey) {
                return _findAt(self2, fd, size, pos + adjustment, pos, adjustment, searchKey, callback, key);
              } else {
                return _findAt(self2, fd, size, pos - adjustment, pos, adjustment, searchKey, callback, key);
              }
            }
          });
        }
      };
      _getFileSize = function(path) {
        var stat;
        stat = fs.statSync(path);
        return stat.size;
      };
      IndexFile2.prototype.find = function(searchKey, callback) {
        var self2;
        self2 = this;
        return this.open(function(err, fd) {
          var pos, size;
          if (err != null) {
            return callback(err, null);
          }
          size = _getFileSize(this.filePath) - 1;
          pos = Math.ceil(size / 2);
          return _findAt(self2, fd, size, pos, null, pos, searchKey, function(err2, result) {
            return callback.call(self2, err2, result);
          });
        });
      };
      IndexFile2.prototype.lookupFromFile = function(word, callback) {
        return this.find(word, function(err, record) {
          var i, indexRecord, j, k, offsets, ptrs, ref, ref1;
          if (err != null) {
            return callback.call(this, err, null);
          }
          indexRecord = null;
          if (record.status === "hit") {
            ptrs = [];
            offsets = [];
            for (i = j = 0, ref = parseInt(record.tokens[3]) - 1; j <= ref; i = j += 1) {
              ptrs.push(record.tokens[i]);
            }
            for (i = k = 0, ref1 = parseInt(record.tokens[2]) - 1; k <= ref1; i = k += 1) {
              offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));
            }
            indexRecord = {
              lemma: record.tokens[0],
              pos: record.tokens[1],
              ptrSymbol: ptrs,
              senseCnt: parseInt(record.tokens[ptrs.length + 4], 10),
              tagsenseCnt: parseInt(record.tokens[ptrs.length + 5], 10),
              synsetOffset: offsets
            };
          }
          return callback.call(this, null, indexRecord);
        });
      };
      IndexFile2.prototype.lookup = function(word, callback) {
        return this.lookupFromFile(word, callback);
      };
      return IndexFile2;
    }(WordNetFile);
  }
});

// node_modules/node-wordnet/lib/data_file.js
var require_data_file = __commonJS({
  "node_modules/node-wordnet/lib/data_file.js"(exports2, module2) {
    var DataFile;
    var WordNetFile;
    var fs;
    var util;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    WordNetFile = require_wordnet_file();
    fs = require_fs();
    util = require_util();
    module2.exports = DataFile = function(superClass) {
      extend(DataFile2, superClass);
      function DataFile2(dataDir, name) {
        DataFile2.__super__.constructor.call(this, dataDir, "data." + name);
      }
      DataFile2.prototype.get = function(location, callback) {
        var buff, self2;
        self2 = this;
        buff = new Buffer(4096);
        return this.open(function(err, fd) {
          if (err != null) {
            return callback.call(self2, err, null);
          }
          return this.appendLineChar(fd, location, 0, buff, function(err2, line) {
            var base, data, definition, element, examples, glossArray, i, j, k, l2, len, m, ptrOffset, ptrs, ref, ref1, synonyms, synsetOffset, tokens, wCnt;
            if (err2 != null) {
              return callback.call(self2, err2, null);
            }
            data = line.split("| ");
            tokens = data[0].split(/\s+/);
            ptrs = [];
            wCnt = parseInt(tokens[3], 16);
            synonyms = [];
            for (i = j = 0, ref = wCnt - 1; j <= ref; i = j += 1) {
              synonyms.push(tokens[4 + i * 2]);
            }
            ptrOffset = (wCnt - 1) * 2 + 6;
            for (i = l2 = 0, ref1 = parseInt(tokens[ptrOffset], 10) - 1; l2 <= ref1; i = l2 += 1) {
              base = i * 4 + ptrOffset;
              ptrs.push({
                pointerSymbol: tokens[base + 1],
                synsetOffset: parseInt(tokens[base + 2], 10),
                pos: tokens[base + 3],
                sourceTarget: tokens[base + 4]
              });
            }
            glossArray = data[1].split("; ");
            definition = glossArray[0];
            examples = glossArray.slice(1);
            for (k = m = 0, len = examples.length; m < len; k = ++m) {
              element = examples[k];
              examples[k] = examples[k].replace(/\"/g, "").replace(/\s\s+/g, "");
            }
            synsetOffset = parseInt(tokens[0], 10);
            if (synsetOffset !== location) {
              return callback.call(self2, "Invalid synsetOffset: " + location, null);
            }
            return callback.call(self2, null, {
              synsetOffset: parseInt(tokens[0], 10),
              lexFilenum: parseInt(tokens[1], 10),
              pos: tokens[2],
              wCnt,
              lemma: tokens[4],
              synonyms,
              lexId: tokens[5],
              ptrs,
              gloss: data[1],
              def: definition,
              exp: examples
            });
          });
        });
      };
      return DataFile2;
    }(WordNetFile);
  }
});

// node_modules/async/lib/async.js
var require_async = __commonJS({
  "node_modules/async/lib/async.js"(exports2, module2) {
    (function() {
      var async = {};
      var root, previous_async;
      root = this;
      if (root != null) {
        previous_async = root.async;
      }
      async.noConflict = function() {
        root.async = previous_async;
        return async;
      };
      function only_once(fn) {
        var called = false;
        return function() {
          if (called)
            throw new Error("Callback was already called.");
          called = true;
          fn.apply(root, arguments);
        };
      }
      var _toString = Object.prototype.toString;
      var _isArray = Array.isArray || function(obj2) {
        return _toString.call(obj2) === "[object Array]";
      };
      var _each = function(arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
          iterator(arr[i], i, arr);
        }
      };
      var _map = function(arr, iterator) {
        if (arr.map) {
          return arr.map(iterator);
        }
        var results = [];
        _each(arr, function(x, i, a) {
          results.push(iterator(x, i, a));
        });
        return results;
      };
      var _reduce = function(arr, iterator, memo) {
        if (arr.reduce) {
          return arr.reduce(iterator, memo);
        }
        _each(arr, function(x, i, a) {
          memo = iterator(memo, x, i, a);
        });
        return memo;
      };
      var _keys = function(obj2) {
        if (Object.keys) {
          return Object.keys(obj2);
        }
        var keys = [];
        for (var k in obj2) {
          if (obj2.hasOwnProperty(k)) {
            keys.push(k);
          }
        }
        return keys;
      };
      if (typeof process === "undefined" || !process.nextTick) {
        if (typeof setImmediate === "function") {
          async.nextTick = function(fn) {
            setImmediate(fn);
          };
          async.setImmediate = async.nextTick;
        } else {
          async.nextTick = function(fn) {
            setTimeout(fn, 0);
          };
          async.setImmediate = async.nextTick;
        }
      } else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== "undefined") {
          async.setImmediate = function(fn) {
            setImmediate(fn);
          };
        } else {
          async.setImmediate = async.nextTick;
        }
      }
      async.each = function(arr, iterator, callback) {
        callback = callback || function() {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        _each(arr, function(x) {
          iterator(x, only_once(done));
        });
        function done(err) {
          if (err) {
            callback(err);
            callback = function() {
            };
          } else {
            completed += 1;
            if (completed >= arr.length) {
              callback();
            }
          }
        }
      };
      async.forEach = async.each;
      async.eachSeries = function(arr, iterator, callback) {
        callback = callback || function() {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        var iterate = function() {
          iterator(arr[completed], function(err) {
            if (err) {
              callback(err);
              callback = function() {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback();
              } else {
                iterate();
              }
            }
          });
        };
        iterate();
      };
      async.forEachSeries = async.eachSeries;
      async.eachLimit = function(arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
      };
      async.forEachLimit = async.eachLimit;
      var _eachLimit = function(limit) {
        return function(arr, iterator, callback) {
          callback = callback || function() {
          };
          if (!arr.length || limit <= 0) {
            return callback();
          }
          var completed = 0;
          var started = 0;
          var running = 0;
          (function replenish() {
            if (completed >= arr.length) {
              return callback();
            }
            while (running < limit && started < arr.length) {
              started += 1;
              running += 1;
              iterator(arr[started - 1], function(err) {
                if (err) {
                  callback(err);
                  callback = function() {
                  };
                } else {
                  completed += 1;
                  running -= 1;
                  if (completed >= arr.length) {
                    callback();
                  } else {
                    replenish();
                  }
                }
              });
            }
          })();
        };
      };
      var doParallel = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async.each].concat(args));
        };
      };
      var doParallelLimit = function(limit, fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
      };
      var doSeries = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async.eachSeries].concat(args));
        };
      };
      var _asyncMap = function(eachfn, arr, iterator, callback) {
        arr = _map(arr, function(x, i) {
          return { index: i, value: x };
        });
        if (!callback) {
          eachfn(arr, function(x, callback2) {
            iterator(x.value, function(err) {
              callback2(err);
            });
          });
        } else {
          var results = [];
          eachfn(arr, function(x, callback2) {
            iterator(x.value, function(err, v) {
              results[x.index] = v;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async.map = doParallel(_asyncMap);
      async.mapSeries = doSeries(_asyncMap);
      async.mapLimit = function(arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
      };
      var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
      };
      async.reduce = function(arr, memo, iterator, callback) {
        async.eachSeries(arr, function(x, callback2) {
          iterator(memo, x, function(err, v) {
            memo = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, memo);
        });
      };
      async.inject = async.reduce;
      async.foldl = async.reduce;
      async.reduceRight = function(arr, memo, iterator, callback) {
        var reversed = _map(arr, function(x) {
          return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
      };
      async.foldr = async.reduceRight;
      var _filter = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(v) {
            if (v) {
              results.push(x);
            }
            callback2();
          });
        }, function(err) {
          callback(_map(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      };
      async.filter = doParallel(_filter);
      async.filterSeries = doSeries(_filter);
      async.select = async.filter;
      async.selectSeries = async.filterSeries;
      var _reject = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(v) {
            if (!v) {
              results.push(x);
            }
            callback2();
          });
        }, function(err) {
          callback(_map(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      };
      async.reject = doParallel(_reject);
      async.rejectSeries = doSeries(_reject);
      var _detect = function(eachfn, arr, iterator, main_callback) {
        eachfn(arr, function(x, callback) {
          iterator(x, function(result) {
            if (result) {
              main_callback(x);
              main_callback = function() {
              };
            } else {
              callback();
            }
          });
        }, function(err) {
          main_callback();
        });
      };
      async.detect = doParallel(_detect);
      async.detectSeries = doSeries(_detect);
      async.some = function(arr, iterator, main_callback) {
        async.each(arr, function(x, callback) {
          iterator(x, function(v) {
            if (v) {
              main_callback(true);
              main_callback = function() {
              };
            }
            callback();
          });
        }, function(err) {
          main_callback(false);
        });
      };
      async.any = async.some;
      async.every = function(arr, iterator, main_callback) {
        async.each(arr, function(x, callback) {
          iterator(x, function(v) {
            if (!v) {
              main_callback(false);
              main_callback = function() {
              };
            }
            callback();
          });
        }, function(err) {
          main_callback(true);
        });
      };
      async.all = async.every;
      async.sortBy = function(arr, iterator, callback) {
        async.map(arr, function(x, callback2) {
          iterator(x, function(err, criteria) {
            if (err) {
              callback2(err);
            } else {
              callback2(null, { value: x, criteria });
            }
          });
        }, function(err, results) {
          if (err) {
            return callback(err);
          } else {
            var fn = function(left, right) {
              var a = left.criteria, b = right.criteria;
              return a < b ? -1 : a > b ? 1 : 0;
            };
            callback(null, _map(results.sort(fn), function(x) {
              return x.value;
            }));
          }
        });
      };
      async.auto = function(tasks, callback) {
        callback = callback || function() {
        };
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
          return callback();
        }
        var results = {};
        var listeners = [];
        var addListener = function(fn) {
          listeners.unshift(fn);
        };
        var removeListener = function(fn) {
          for (var i = 0; i < listeners.length; i += 1) {
            if (listeners[i] === fn) {
              listeners.splice(i, 1);
              return;
            }
          }
        };
        var taskComplete = function() {
          remainingTasks--;
          _each(listeners.slice(0), function(fn) {
            fn();
          });
        };
        addListener(function() {
          if (!remainingTasks) {
            var theCallback = callback;
            callback = function() {
            };
            theCallback(null, results);
          }
        });
        _each(keys, function(k) {
          var task = _isArray(tasks[k]) ? tasks[k] : [tasks[k]];
          var taskCallback = function(err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            if (err) {
              var safeResults = {};
              _each(_keys(results), function(rkey) {
                safeResults[rkey] = results[rkey];
              });
              safeResults[k] = args;
              callback(err, safeResults);
              callback = function() {
              };
            } else {
              results[k] = args;
              async.setImmediate(taskComplete);
            }
          };
          var requires = task.slice(0, Math.abs(task.length - 1)) || [];
          var ready = function() {
            return _reduce(requires, function(a, x) {
              return a && results.hasOwnProperty(x);
            }, true) && !results.hasOwnProperty(k);
          };
          if (ready()) {
            task[task.length - 1](taskCallback, results);
          } else {
            var listener = function() {
              if (ready()) {
                removeListener(listener);
                task[task.length - 1](taskCallback, results);
              }
            };
            addListener(listener);
          }
        });
      };
      async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        if (typeof times === "function") {
          callback = task;
          task = times;
          times = DEFAULT_TIMES;
        }
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
          var retryAttempt = function(task2, finalAttempt) {
            return function(seriesCallback) {
              task2(function(err, result) {
                seriesCallback(!err || finalAttempt, { err, result });
              }, wrappedResults);
            };
          };
          while (times) {
            attempts.push(retryAttempt(task, !(times -= 1)));
          }
          async.series(attempts, function(done, data) {
            data = data[data.length - 1];
            (wrappedCallback || callback)(data.err, data.result);
          });
        };
        return callback ? wrappedTask() : wrappedTask;
      };
      async.waterfall = function(tasks, callback) {
        callback = callback || function() {
        };
        if (!_isArray(tasks)) {
          var err = new Error("First argument to waterfall must be an array of functions");
          return callback(err);
        }
        if (!tasks.length) {
          return callback();
        }
        var wrapIterator = function(iterator) {
          return function(err2) {
            if (err2) {
              callback.apply(null, arguments);
              callback = function() {
              };
            } else {
              var args = Array.prototype.slice.call(arguments, 1);
              var next = iterator.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              async.setImmediate(function() {
                iterator.apply(null, args);
              });
            }
          };
        };
        wrapIterator(async.iterator(tasks))();
      };
      var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function() {
        };
        if (_isArray(tasks)) {
          eachfn.map(tasks, function(fn, callback2) {
            if (fn) {
              fn(function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback2.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          eachfn.each(_keys(tasks), function(k, callback2) {
            tasks[k](function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async.parallel = function(tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
      };
      async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
      };
      async.series = function(tasks, callback) {
        callback = callback || function() {
        };
        if (_isArray(tasks)) {
          async.mapSeries(tasks, function(fn, callback2) {
            if (fn) {
              fn(function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback2.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          async.eachSeries(_keys(tasks), function(k, callback2) {
            tasks[k](function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async.iterator = function(tasks) {
        var makeCallback = function(index) {
          var fn = function() {
            if (tasks.length) {
              tasks[index].apply(null, arguments);
            }
            return fn.next();
          };
          fn.next = function() {
            return index < tasks.length - 1 ? makeCallback(index + 1) : null;
          };
          return fn;
        };
        return makeCallback(0);
      };
      async.apply = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return fn.apply(
            null,
            args.concat(Array.prototype.slice.call(arguments))
          );
        };
      };
      var _concat = function(eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function(x, cb) {
          fn(x, function(err, y) {
            r = r.concat(y || []);
            cb(err);
          });
        }, function(err) {
          callback(err, r);
        });
      };
      async.concat = doParallel(_concat);
      async.concatSeries = doSeries(_concat);
      async.whilst = function(test, iterator, callback) {
        if (test()) {
          iterator(function(err) {
            if (err) {
              return callback(err);
            }
            async.whilst(test, iterator, callback);
          });
        } else {
          callback();
        }
      };
      async.doWhilst = function(iterator, test, callback) {
        iterator(function(err) {
          if (err) {
            return callback(err);
          }
          var args = Array.prototype.slice.call(arguments, 1);
          if (test.apply(null, args)) {
            async.doWhilst(iterator, test, callback);
          } else {
            callback();
          }
        });
      };
      async.until = function(test, iterator, callback) {
        if (!test()) {
          iterator(function(err) {
            if (err) {
              return callback(err);
            }
            async.until(test, iterator, callback);
          });
        } else {
          callback();
        }
      };
      async.doUntil = function(iterator, test, callback) {
        iterator(function(err) {
          if (err) {
            return callback(err);
          }
          var args = Array.prototype.slice.call(arguments, 1);
          if (!test.apply(null, args)) {
            async.doUntil(iterator, test, callback);
          } else {
            callback();
          }
        });
      };
      async.queue = function(worker, concurrency) {
        if (concurrency === void 0) {
          concurrency = 1;
        }
        function _insert(q2, data, pos, callback) {
          if (!q2.started) {
            q2.started = true;
          }
          if (!_isArray(data)) {
            data = [data];
          }
          if (data.length == 0) {
            return async.setImmediate(function() {
              if (q2.drain) {
                q2.drain();
              }
            });
          }
          _each(data, function(task) {
            var item = {
              data: task,
              callback: typeof callback === "function" ? callback : null
            };
            if (pos) {
              q2.tasks.unshift(item);
            } else {
              q2.tasks.push(item);
            }
            if (q2.saturated && q2.tasks.length === q2.concurrency) {
              q2.saturated();
            }
            async.setImmediate(q2.process);
          });
        }
        var workers = 0;
        var q = {
          tasks: [],
          concurrency,
          saturated: null,
          empty: null,
          drain: null,
          started: false,
          paused: false,
          push: function(data, callback) {
            _insert(q, data, false, callback);
          },
          kill: function() {
            q.drain = null;
            q.tasks = [];
          },
          unshift: function(data, callback) {
            _insert(q, data, true, callback);
          },
          process: function() {
            if (!q.paused && workers < q.concurrency && q.tasks.length) {
              var task = q.tasks.shift();
              if (q.empty && q.tasks.length === 0) {
                q.empty();
              }
              workers += 1;
              var next = function() {
                workers -= 1;
                if (task.callback) {
                  task.callback.apply(task, arguments);
                }
                if (q.drain && q.tasks.length + workers === 0) {
                  q.drain();
                }
                q.process();
              };
              var cb = only_once(next);
              worker(task.data, cb);
            }
          },
          length: function() {
            return q.tasks.length;
          },
          running: function() {
            return workers;
          },
          idle: function() {
            return q.tasks.length + workers === 0;
          },
          pause: function() {
            if (q.paused === true) {
              return;
            }
            q.paused = true;
          },
          resume: function() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            for (var w = 1; w <= q.concurrency; w++) {
              async.setImmediate(q.process);
            }
          }
        };
        return q;
      };
      async.priorityQueue = function(worker, concurrency) {
        function _compareTasks(a, b) {
          return a.priority - b.priority;
        }
        ;
        function _binarySearch(sequence, item, compare) {
          var beg = -1, end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + (end - beg + 1 >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        function _insert(q2, data, priority, callback) {
          if (!q2.started) {
            q2.started = true;
          }
          if (!_isArray(data)) {
            data = [data];
          }
          if (data.length == 0) {
            return async.setImmediate(function() {
              if (q2.drain) {
                q2.drain();
              }
            });
          }
          _each(data, function(task) {
            var item = {
              data: task,
              priority,
              callback: typeof callback === "function" ? callback : null
            };
            q2.tasks.splice(_binarySearch(q2.tasks, item, _compareTasks) + 1, 0, item);
            if (q2.saturated && q2.tasks.length === q2.concurrency) {
              q2.saturated();
            }
            async.setImmediate(q2.process);
          });
        }
        var q = async.queue(worker, concurrency);
        q.push = function(data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        delete q.unshift;
        return q;
      };
      async.cargo = function(worker, payload) {
        var working = false, tasks = [];
        var cargo = {
          tasks,
          payload,
          saturated: null,
          empty: null,
          drain: null,
          drained: true,
          push: function(data, callback) {
            if (!_isArray(data)) {
              data = [data];
            }
            _each(data, function(task) {
              tasks.push({
                data: task,
                callback: typeof callback === "function" ? callback : null
              });
              cargo.drained = false;
              if (cargo.saturated && tasks.length === payload) {
                cargo.saturated();
              }
            });
            async.setImmediate(cargo.process);
          },
          process: function process2() {
            if (working)
              return;
            if (tasks.length === 0) {
              if (cargo.drain && !cargo.drained)
                cargo.drain();
              cargo.drained = true;
              return;
            }
            var ts = typeof payload === "number" ? tasks.splice(0, payload) : tasks.splice(0, tasks.length);
            var ds = _map(ts, function(task) {
              return task.data;
            });
            if (cargo.empty)
              cargo.empty();
            working = true;
            worker(ds, function() {
              working = false;
              var args = arguments;
              _each(ts, function(data) {
                if (data.callback) {
                  data.callback.apply(null, args);
                }
              });
              process2();
            });
          },
          length: function() {
            return tasks.length;
          },
          running: function() {
            return working;
          }
        };
        return cargo;
      };
      var _console_fn = function(name) {
        return function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          fn.apply(null, args.concat([function(err) {
            var args2 = Array.prototype.slice.call(arguments, 1);
            if (typeof console !== "undefined") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name]) {
                _each(args2, function(x) {
                  console[name](x);
                });
              }
            }
          }]));
        };
      };
      async.log = _console_fn("log");
      async.dir = _console_fn("dir");
      async.memoize = function(fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function(x) {
          return x;
        };
        var memoized = function() {
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          var key = hasher.apply(null, args);
          if (key in memo) {
            async.nextTick(function() {
              callback.apply(null, memo[key]);
            });
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            fn.apply(null, args.concat([function() {
              memo[key] = arguments;
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l2 = q.length; i < l2; i++) {
                q[i].apply(null, arguments);
              }
            }]));
          }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      };
      async.unmemoize = function(fn) {
        return function() {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      };
      async.times = function(count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
          counter.push(i);
        }
        return async.map(counter, iterator, callback);
      };
      async.timesSeries = function(count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
          counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
      };
      async.seq = function() {
        var fns = arguments;
        return function() {
          var that = this;
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          async.reduce(
            fns,
            args,
            function(newargs, fn, cb) {
              fn.apply(that, newargs.concat([function() {
                var err = arguments[0];
                var nextargs = Array.prototype.slice.call(arguments, 1);
                cb(err, nextargs);
              }]));
            },
            function(err, results) {
              callback.apply(that, [err].concat(results));
            }
          );
        };
      };
      async.compose = function() {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
      };
      var _applyEach = function(eachfn, fns) {
        var go = function() {
          var that = this;
          var args2 = Array.prototype.slice.call(arguments);
          var callback = args2.pop();
          return eachfn(
            fns,
            function(fn, cb) {
              fn.apply(that, args2.concat([cb]));
            },
            callback
          );
        };
        if (arguments.length > 2) {
          var args = Array.prototype.slice.call(arguments, 2);
          return go.apply(this, args);
        } else {
          return go;
        }
      };
      async.applyEach = doParallel(_applyEach);
      async.applyEachSeries = doSeries(_applyEach);
      async.forever = function(fn, callback) {
        function next(err) {
          if (err) {
            if (callback) {
              return callback(err);
            }
            throw err;
          }
          fn(next);
        }
        next();
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = async;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return async;
        });
      } else {
        root.async = async;
      }
    })();
  }
});

// node_modules/bluebird/js/browser/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f2;
        "undefined" != typeof window ? f2 = window : "undefined" != typeof global ? f2 = global : "undefined" != typeof self && (f2 = self), f2.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n[o2] = { exports: {} };
            t[o2][0].call(l2.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l2, l2.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule.js");
        var Queue = _dereq_2("./queue.js");
        var util = _dereq_2("./util.js");
        function Async() {
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._trampolineEnabled = true;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
        }
        Async.prototype.disableTrampolineIfNecessary = function() {
          if (util.hasDevTools) {
            this._trampolineEnabled = false;
          }
        };
        Async.prototype.enableTrampoline = function() {
          if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
        };
        Async.prototype.haveItemsQueued = function() {
          return this._normalQueue.length() > 0;
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
            }
        };
        function AsyncInvokeLater(fn, receiver, arg) {
          this._lateQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver, arg) {
          this._normalQueue.push(fn, receiver, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        if (!util.hasDevTools) {
          Async.prototype.invokeLater = AsyncInvokeLater;
          Async.prototype.invoke = AsyncInvoke;
          Async.prototype.settlePromises = AsyncSettlePromises;
        } else {
          if (schedule.isStatic) {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          }
          Async.prototype.invokeLater = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                setTimeout(function() {
                  fn.call(receiver, arg);
                }, 100);
              });
            }
          };
          Async.prototype.invoke = function(fn, receiver, arg) {
            if (this._trampolineEnabled) {
              AsyncInvoke.call(this, fn, receiver, arg);
            } else {
              this._schedule(function() {
                fn.call(receiver, arg);
              });
            }
          };
          Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
              AsyncSettlePromises.call(this, promise);
            } else {
              this._schedule(function() {
                promise._settlePromises();
              });
            }
          };
        }
        Async.prototype.invokeFirst = function(fn, receiver, arg) {
          this._normalQueue.unshift(fn, receiver, arg);
          this._queueTick();
        };
        Async.prototype._drainQueue = function(queue) {
          while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
              fn._settlePromises();
              continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
          }
        };
        Async.prototype._drainQueues = function() {
          this._drainQueue(this._normalQueue);
          this._reset();
          this._drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = new Async();
        module2.exports.firstLineError = firstLineError;
      }, { "./queue.js": 28, "./schedule.js": 31, "./util.js": 38 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise) {
          var rejectThis = function(_, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if (this._isPending()) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, ret2._progress, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                ret2._progress,
                ret2,
                context
              );
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 131072;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~131072;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 131072) === 131072;
          };
          Promise2.bind = function(thisArg, value) {
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              maybePromise._then(function() {
                ret2._resolveCallback(value);
              }, ret2._reject, ret2._progress, ret2, null);
            } else {
              ret2._resolveCallback(value);
            }
            return ret2;
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise.js")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise.js": 23 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys[i]];
                  cache[" size"] = keys.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var $_len = arguments.length;
            var args = new Array($_len - 1);
            for (var $_i = 1; $_i < $_len; ++$_i) {
              args[$_i - 1] = arguments[$_i];
            }
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util.js": 38 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var errors = _dereq_2("./errors.js");
          var async = _dereq_2("./async.js");
          var CancellationError = errors.CancellationError;
          Promise2.prototype._cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            var parent;
            var promiseToReject = this;
            while ((parent = promiseToReject._cancellationParent) !== void 0 && parent.isCancellable()) {
              promiseToReject = parent;
            }
            this._unsetCancellable();
            promiseToReject._target()._rejectCallback(reason, false, true);
          };
          Promise2.prototype.cancel = function(reason) {
            if (!this.isCancellable())
              return this;
            if (reason === void 0)
              reason = new CancellationError();
            async.invokeLater(this._cancel, this, reason);
            return this;
          };
          Promise2.prototype.cancellable = function() {
            if (this._cancellable())
              return this;
            async.enableTrampoline();
            this._setCancellable();
            this._cancellationParent = void 0;
            return this;
          };
          Promise2.prototype.uncancellable = function() {
            var ret2 = this.then();
            ret2._unsetCancellable();
            return ret2;
          };
          Promise2.prototype.fork = function(didFulfill, didReject, didProgress) {
            var ret2 = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            ret2._setCancellable();
            ret2._cancellationParent = void 0;
            return ret2;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var warn;
          function CapturedTrace(parent) {
            this._parent = parent;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.parent = function() {
            return this._parent;
          };
          CapturedTrace.prototype.hasParent = function() {
            return this._parent !== void 0;
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = CapturedTrace.parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = stackFramePattern.test(line) || "    (No stack trace)" === line;
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0) {
              stack = stack.slice(i);
            }
            return stack;
          }
          CapturedTrace.parseStackAndMessage = function(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: cleanStack(stack)
            };
          };
          CapturedTrace.formatAndLogError = function(error, title) {
            if (typeof console !== "undefined") {
              var message;
              if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof warn === "function") {
                warn(message);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          };
          CapturedTrace.unhandledRejection = function(reason) {
            CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
          };
          CapturedTrace.isSupported = function() {
            return typeof captureStackTrace === "function";
          };
          CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent(name, reason, promise);
            } catch (e) {
              globalEventFired = true;
              async.throwLater(e);
            }
            var domEventFired = false;
            if (fireDomEvent) {
              try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                  reason,
                  promise
                });
              } catch (e) {
                domEventFired = true;
                async.throwLater(e);
              }
            }
            if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
              CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
            }
          };
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2.toString();
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          CapturedTrace.setBounds = function(firstLineError, lastLineError) {
            if (!CapturedTrace.isSupported())
              return;
            var firstStackLines = firstLineError.stack.split("\n");
            var lastStackLines = lastLineError.stack.split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result = parseLineInfo(firstStackLines[i]);
              if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result = parseLineInfo(lastStackLines[i]);
              if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit = Error.stackTraceLimit + 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace2(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          var fireDomEvent;
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                  return process.emit(name, promise);
                } else {
                  return process.emit(name, reason, promise);
                }
              };
            } else {
              var customEventWorks = false;
              var anyEventWorks = true;
              try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
              } catch (e) {
              }
              if (!customEventWorks) {
                try {
                  var event = document.createEvent("CustomEvent");
                  event.initCustomEvent("testingtheevent", false, true, {});
                  self.dispatchEvent(event);
                } catch (e) {
                  anyEventWorks = false;
                }
              }
              if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                  var event2;
                  if (customEventWorks) {
                    event2 = new self.CustomEvent(type, {
                      detail,
                      bubbles: false,
                      cancelable: true
                    });
                  } else if (self.dispatchEvent) {
                    event2 = document.createEvent("CustomEvent");
                    event2.initCustomEvent(type, false, true, detail);
                  }
                  return event2 ? !self.dispatchEvent(event2) : false;
                };
              }
              var toWindowMethodNameMap = {};
              toWindowMethodNameMap["unhandledRejection"] = "onunhandledRejection".toLowerCase();
              toWindowMethodNameMap["rejectionHandled"] = "onrejectionHandled".toLowerCase();
              return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method)
                  return false;
                if (name === "rejectionHandled") {
                  method.call(self, promise);
                } else {
                  method.call(self, reason, promise);
                }
                return true;
              };
            }
          }();
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            warn = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              warn = function(message) {
                process.stderr.write("\x1B[31m" + message + "\x1B[39m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              warn = function(message) {
                console.warn("%c" + message, "color: red");
              };
            }
          }
          return CapturedTrace;
        };
      }, { "./async.js": 2, "./util.js": 38 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util.js");
          var errors = _dereq_2("./errors.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var keys = _dereq_2("./es5.js").keys;
          var TypeError2 = errors.TypeError;
          function CatchFilter(instances, callback, promise) {
            this._instances = instances;
            this._callback = callback;
            this._promise = promise;
          }
          function safePredicate(predicate, e) {
            var safeObject = {};
            var retfilter = tryCatch2(predicate).call(safeObject, e);
            if (retfilter === errorObj2)
              return retfilter;
            var safeKeys = keys(safeObject);
            if (safeKeys.length) {
              errorObj2.e = new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n");
              return errorObj2;
            }
            return retfilter;
          }
          CatchFilter.prototype.doFilter = function(e) {
            var cb = this._callback;
            var promise = this._promise;
            var boundTo = promise._boundValue();
            for (var i = 0, len = this._instances.length; i < len; ++i) {
              var item = this._instances[i];
              var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
              if (itemIsErrorType && e instanceof item) {
                var ret2 = tryCatch2(cb).call(boundTo, e);
                if (ret2 === errorObj2) {
                  NEXT_FILTER.e = ret2.e;
                  return NEXT_FILTER;
                }
                return ret2;
              } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj2) {
                  e = errorObj2.e;
                  break;
                } else if (shouldHandle) {
                  var ret2 = tryCatch2(cb).call(boundTo, e);
                  if (ret2 === errorObj2) {
                    NEXT_FILTER.e = ret2.e;
                    return NEXT_FILTER;
                  }
                  return ret2;
                }
              }
            }
            NEXT_FILTER.e = e;
            return NEXT_FILTER;
          };
          return CatchFilter;
        };
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace, isDebugging) {
          var contextStack = [];
          function Context() {
            this._trace = new CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (!isDebugging())
              return;
            if (this._trace !== void 0) {
              contextStack.pop();
            }
          };
          function createContext() {
            if (isDebugging())
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Promise2.prototype._peekContext = peekContext;
          Promise2.prototype._pushContext = Context.prototype._pushContext;
          Promise2.prototype._popContext = Context.prototype._popContext;
          return createContext;
        };
      }, {}], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, CapturedTrace) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var Warning = _dereq_2("./errors.js").Warning;
          var util = _dereq_2("./util.js");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var debugging = util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || true);
          if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0)
            debugging = false;
          if (debugging) {
            async.disableTrampolineIfNecessary();
          }
          Promise2.prototype._ignoreRejections = function() {
            this._unsetRejectionIsUnhandled();
            this._bitField = this._bitField | 16777216;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 16777216) !== 0)
              return;
            this._setRejectionIsUnhandled();
            async.invokeLater(this._notifyUnhandledRejection, this, void 0);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            CapturedTrace.fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._getCarriedStackTrace() || this._settledValue;
              this._setUnhandledRejectionIsNotified();
              CapturedTrace.fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 524288;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~524288;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 524288) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 2097152;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~2097152;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 2097152) > 0;
          };
          Promise2.prototype._setCarriedStackTrace = function(capturedTrace) {
            this._bitField = this._bitField | 1048576;
            this._fulfillmentHandler0 = capturedTrace;
          };
          Promise2.prototype._isCarryingStackTrace = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._getCarriedStackTrace = function() {
            return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
          };
          Promise2.prototype._captureStackTrace = function() {
            if (debugging) {
              this._trace = new CapturedTrace(this._peekContext());
            }
            return this;
          };
          Promise2.prototype._attachExtraTrace = function(error, ignoreSelf) {
            if (debugging && canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          };
          Promise2.prototype._warn = function(message) {
            var warning = new Warning(message);
            var ctx = this._peekContext();
            if (ctx) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = CapturedTrace.parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            CapturedTrace.formatAndLogError(warning, "");
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var domain = getDomain();
            possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var domain = getDomain();
            unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : domain.bind(fn) : void 0;
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && debugging === false) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n");
            }
            debugging = CapturedTrace.isSupported();
            if (debugging) {
              async.disableTrampolineIfNecessary();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return debugging && CapturedTrace.isSupported();
          };
          if (!CapturedTrace.isSupported()) {
            Promise2.longStackTraces = function() {
            };
            debugging = false;
          }
          return function() {
            return debugging;
          };
        };
      }, { "./async.js": 2, "./errors.js": 13, "./util.js": 38 }], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var isPrimitive2 = util.isPrimitive;
        module2.exports = function(Promise2) {
          var returner = function() {
            return this;
          };
          var thrower2 = function() {
            throw this;
          };
          var returnUndefined = function() {
          };
          var throwUndefined = function() {
            throw void 0;
          };
          var wrapper = function(value, action) {
            if (action === 1) {
              return function() {
                throw value;
              };
            } else if (action === 2) {
              return function() {
                return value;
              };
            }
          };
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value === void 0)
              return this.then(returnUndefined);
            if (isPrimitive2(value)) {
              return this._then(
                wrapper(value, 2),
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else if (value instanceof Promise2) {
              value._ignoreRejections();
            }
            return this._then(returner, void 0, void 0, value, void 0);
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            if (reason === void 0)
              return this.then(throwUndefined);
            if (isPrimitive2(reason)) {
              return this._then(
                wrapper(reason, 1),
                void 0,
                void 0,
                void 0,
                void 0
              );
            }
            return this._then(thrower2, void 0, void 0, reason, void 0);
          };
        };
      }, { "./util.js": 38 }], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, null, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, null, INTERNAL);
          };
        };
      }, {}], 13: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5.js");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util.js");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          notEnumerableProp2(Error, "__BluebirdErrorTypes__", errorTypes);
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 14: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, NEXT_FILTER, tryConvertToPromise) {
          var util = _dereq_2("./util.js");
          var isPrimitive2 = util.isPrimitive;
          var thrower2 = util.thrower;
          function returnThis() {
            return this;
          }
          function throwThis() {
            throw this;
          }
          function return$(r) {
            return function() {
              return r;
            };
          }
          function throw$(r) {
            return function() {
              throw r;
            };
          }
          function promisedFinally(ret2, reasonOrValue, isFulfilled) {
            var then;
            if (isPrimitive2(reasonOrValue)) {
              then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
            } else {
              then = isFulfilled ? returnThis : throwThis;
            }
            return ret2._then(then, thrower2, void 0, reasonOrValue, void 0);
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue()) : handler();
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(
                  maybePromise,
                  reasonOrValue,
                  promise.isFulfilled()
                );
              }
            }
            if (promise.isRejected()) {
              NEXT_FILTER.e = reasonOrValue;
              return NEXT_FILTER;
            } else {
              return reasonOrValue;
            }
          }
          function tapHandler(value) {
            var promise = this.promise;
            var handler = this.handler;
            var ret2 = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
            if (ret2 !== void 0) {
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
              }
            }
            return value;
          }
          Promise2.prototype._passThroughHandler = function(handler, isFinally) {
            if (typeof handler !== "function")
              return this.then();
            var promiseAndHandler = {
              promise: this,
              handler
            };
            return this._then(
              isFinally ? finallyHandler : tapHandler,
              isFinally ? finallyHandler : void 0,
              void 0,
              promiseAndHandler,
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThroughHandler(handler, true);
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThroughHandler(handler, false);
          };
        };
      }, { "./util.js": 38 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise) {
          var errors = _dereq_2("./errors.js");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
            var promise = this._promise = new Promise2(INTERNAL);
            promise._captureStackTrace();
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
          }
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._next(void 0);
          };
          PromiseSpawn.prototype._continue = function(result) {
            if (result === errorObj2) {
              return this._promise._rejectCallback(result.e, false, true);
            }
            var value = result.value;
            if (result.done === true) {
              this._promise._resolveCallback(value);
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._throw(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise._then(
                this._next,
                this._throw,
                void 0,
                this,
                null
              );
            }
          };
          PromiseSpawn.prototype._throw = function(reason) {
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._next = function(value) {
            this._promise._pushContext();
            var result = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result);
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              spawn._generator = generator;
              spawn._next(void 0);
              return spawn.promise();
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL) {
          var util = _dereq_2("./util.js");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var caller = function(count) {
                var values = [];
                for (var i2 = 1; i2 <= count; ++i2)
                  values.push("holder.p" + i2);
                return new Function("holder", "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ".replace(/values/g, values.join(", ")));
              };
              var thenCallbacks = [];
              var callers = [void 0];
              for (var i = 1; i <= 5; ++i) {
                thenCallbacks.push(thenCallback(i));
                callers.push(caller(i));
              }
              var Holder = function(total, fn) {
                this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                this.fn = fn;
                this.total = total;
                this.now = 0;
              };
              Holder.prototype.callers = callers;
              Holder.prototype.checkFulfillment = function(promise) {
                var now = this.now;
                now++;
                var total = this.total;
                if (now >= total) {
                  var handler = this.callers[total];
                  promise._pushContext();
                  var ret2 = tryCatch2(handler)(this);
                  promise._popContext();
                  if (ret2 === errorObj2) {
                    promise._rejectCallback(ret2.e, false, true);
                  } else {
                    promise._resolveCallback(ret2);
                  }
                } else {
                  this.now = now;
                }
              };
              var reject = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last = arguments.length - 1;
            var fn;
            if (last > 0 && typeof arguments[last] === "function") {
              fn = arguments[last];
              if (false) {
                if (last < 6 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var holder = new Holder(last, fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      if (maybePromise._isPending()) {
                        maybePromise._then(
                          callbacks[i2],
                          reject,
                          void 0,
                          ret2,
                          holder
                        );
                      } else if (maybePromise._isFulfilled()) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else {
                        ret2._reject(maybePromise._reason());
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  return ret2;
                }
              }
            }
            var $_len = arguments.length;
            var args = new Array($_len);
            for (var $_i = 0; $_i < $_len; ++$_i) {
              args[$_i] = arguments[$_i];
            }
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util.js": 38 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var PENDING = {};
          var EMPTY_ARRAY = [];
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
            async.invoke(init, this, void 0);
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          function init() {
            this._init$(void 0, -2);
          }
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (values[index] === PENDING) {
              values[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var callback = this._callback;
              var receiver = this._promise._boundValue();
              this._promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver, value, index, length);
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  if (limit >= 1)
                    this._inFlight++;
                  values[index] = PENDING;
                  return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              values[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values, preservedValues);
              } else {
                this._resolve(values);
              }
            }
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values) {
            var len = values.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map(promises, fn, options, _filter) {
            var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter);
          }
          Promise2.prototype.map = function(fn, options) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map(this, fn, options, null).promise();
          };
          Promise2.map = function(promises, fn, options, _filter) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            return map(promises, fn, options, _filter).promise();
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              ret2._popContext();
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn, args, ctx) {
            if (typeof fn !== "function") {
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value = util.isArray(args) ? tryCatch2(fn).apply(ctx, args) : tryCatch2(fn).call(ctx, args);
            ret2._popContext();
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false, true);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util.js": 38 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var target = promise._target();
              var newReason = target._getCarriedStackTrace();
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var util = _dereq_2("./util.js");
          var async = _dereq_2("./async.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          Promise2.prototype.progressed = function(handler) {
            return this._then(void 0, void 0, handler, void 0, void 0);
          };
          Promise2.prototype._progress = function(progressValue) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._target()._progressUnchecked(progressValue);
          };
          Promise2.prototype._progressHandlerAt = function(index) {
            return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
          };
          Promise2.prototype._doProgressWith = function(progression) {
            var progressValue = progression.value;
            var handler = progression.handler;
            var promise = progression.promise;
            var receiver = progression.receiver;
            var ret2 = tryCatch2(handler).call(receiver, progressValue);
            if (ret2 === errorObj2) {
              if (ret2.e != null && ret2.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret2.e) ? ret2.e : new Error(util.toString(ret2.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret2.e);
              }
            } else if (ret2 instanceof Promise2) {
              ret2._then(promise._progress, null, null, promise, void 0);
            } else {
              promise._progress(ret2);
            }
          };
          Promise2.prototype._progressUnchecked = function(progressValue) {
            var len = this._length();
            var progress = this._progress;
            for (var i = 0; i < len; i++) {
              var handler = this._progressHandlerAt(i);
              var promise = this._promiseAt(i);
              if (!(promise instanceof Promise2)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                  handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                  receiver._promiseProgressed(progressValue, promise);
                }
                continue;
              }
              if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                  handler,
                  promise,
                  receiver: this._receiverAt(i),
                  value: progressValue
                });
              } else {
                async.invoke(progress, promise, progressValue);
              }
            }
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n");
          };
          var reflect = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          var util = _dereq_2("./util.js");
          var getDomain;
          if (util.isNode) {
            getDomain = function() {
              var ret2 = process.domain;
              if (ret2 === void 0)
                ret2 = null;
              return ret2;
            };
          } else {
            getDomain = function() {
              return null;
            };
          }
          util.notEnumerableProp(Promise2, "_getDomain", getDomain);
          var UNDEFINED_BINDING = {};
          var async = _dereq_2("./async.js");
          var errors = _dereq_2("./errors.js");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = { e: null };
          var tryConvertToPromise = _dereq_2("./thenables.js")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array.js")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection
          );
          var CapturedTrace = _dereq_2("./captured_trace.js")();
          var isDebugging = _dereq_2("./debuggability.js")(Promise2, CapturedTrace);
          var createContext = _dereq_2("./context.js")(Promise2, CapturedTrace, isDebugging);
          var CatchFilter = _dereq_2("./catch_filter.js")(NEXT_FILTER);
          var PromiseResolver = _dereq_2("./promise_resolver.js");
          var nodebackForPromise = PromiseResolver._nodebackForPromise;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError2("the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n");
            }
            if (this.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n");
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._progressHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settledValue = void 0;
            if (resolver !== INTERNAL)
              this._resolveFromResolver(resolver);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(
                    new TypeError2("Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n")
                  );
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              var catchFilter = new CatchFilter(catchInstances, fn, this);
              return this._then(
                void 0,
                catchFilter.doFilter,
                void 0,
                catchFilter,
                void 0
              );
            }
            return this._then(void 0, fn, void 0, void 0, void 0);
          };
          Promise2.prototype.reflect = function() {
            return this._then(reflect, reflect, void 0, this, void 0);
          };
          Promise2.prototype.then = function(didFulfill, didReject, didProgress) {
            if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
          };
          Promise2.prototype.done = function(didFulfill, didReject, didProgress) {
            var promise = this._then(
              didFulfill,
              didReject,
              didProgress,
              void 0,
              void 0
            );
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(didFulfill, didReject) {
            return this.all()._then(didFulfill, didReject, void 0, APPLY, void 0);
          };
          Promise2.prototype.isCancellable = function() {
            return !this.isResolved() && this._cancellable();
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.getNewLibraryCopy = module2.exports;
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            var result = tryCatch2(fn)(nodebackForPromise(ret2));
            if (result === errorObj2) {
              ret2._rejectCallback(result.e, true, true);
            }
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.defer = Promise2.pending = function() {
            var promise = new Promise2(INTERNAL);
            return new PromiseResolver(promise);
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              var val = ret2;
              ret2 = new Promise2(INTERNAL);
              ret2._fulfillUnchecked(val);
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function")
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var prev = async._schedule;
            async._schedule = fn;
            return prev;
          };
          Promise2.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
            var haveInternalData = internalData !== void 0;
            var ret2 = haveInternalData ? internalData : new Promise2(INTERNAL);
            if (!haveInternalData) {
              ret2._propagateFrom(this, 4 | 1);
              ret2._captureStackTrace();
            }
            var target = this._target();
            if (target !== this) {
              if (receiver === void 0)
                receiver = this._boundTo;
              if (!haveInternalData)
                ret2._setIsMigrated();
            }
            var callbackIndex = target._addCallbacks(
              didFulfill,
              didReject,
              didProgress,
              ret2,
              receiver,
              getDomain()
            );
            if (target._isResolved() && !target._isSettlePromisesQueued()) {
              async.invoke(
                target._settlePromiseAtPostResolution,
                target,
                callbackIndex
              );
            }
            return ret2;
          };
          Promise2.prototype._settlePromiseAtPostResolution = function(index) {
            if (this._isRejectionUnhandled())
              this._unsetRejectionIsUnhandled();
            this._settlePromiseAt(index);
          };
          Promise2.prototype._length = function() {
            return this._bitField & 131071;
          };
          Promise2.prototype._isFollowingOrFulfilledOrRejected = function() {
            return (this._bitField & 939524096) > 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 536870912) === 536870912;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -131072 | len & 131071;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 134217728;
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 536870912;
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 33554432;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 33554432) > 0;
          };
          Promise2.prototype._cancellable = function() {
            return (this._bitField & 67108864) > 0;
          };
          Promise2.prototype._setCancellable = function() {
            this._bitField = this._bitField | 67108864;
          };
          Promise2.prototype._unsetCancellable = function() {
            this._bitField = this._bitField & ~67108864;
          };
          Promise2.prototype._setIsMigrated = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._unsetIsMigrated = function() {
            this._bitField = this._bitField & ~4194304;
          };
          Promise2.prototype._isMigrated = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
            if (ret2 === UNDEFINED_BINDING) {
              return void 0;
            } else if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
          };
          Promise2.prototype._boundValue = function() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          };
          Promise2.prototype._migrateCallbacks = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject = follower._rejectionHandlerAt(index);
            var progress = follower._progressHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver = follower._receiverAt(index);
            if (promise instanceof Promise2)
              promise._setIsMigrated();
            if (receiver === void 0)
              receiver = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject, progress, promise, receiver, domain) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              if (receiver !== void 0)
                this._receiver0 = receiver;
              if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject === "function") {
                this._rejectionHandler0 = domain === null ? reject : domain.bind(reject);
              }
              if (typeof progress === "function") {
                this._progressHandler0 = domain === null ? progress : domain.bind(progress);
              }
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promise;
              this[base + 4] = receiver;
              if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
              }
              if (typeof reject === "function") {
                this[base + 1] = domain === null ? reject : domain.bind(reject);
              }
              if (typeof progress === "function") {
                this[base + 2] = domain === null ? progress : domain.bind(progress);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
            var index = this._length();
            if (index >= 131071 - 5) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promiseSlotValue;
              this._receiver0 = receiver;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = promiseSlotValue;
              this[base + 4] = receiver;
            }
            this._setLength(index + 1);
          };
          Promise2.prototype._proxyPromiseArray = function(promiseArray, index) {
            this._setProxyHandlers(promiseArray, index);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false, true);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            var propagationFlags = 1 | (shouldBind ? 4 : 0);
            this._propagateFrom(maybePromise, propagationFlags);
            var promise = maybePromise._target();
            if (promise._isPending()) {
              var len = this._length();
              for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(promise);
            } else if (promise._isFulfilled()) {
              this._fulfillUnchecked(promise._value());
            } else {
              this._rejectUnchecked(
                promise._reason(),
                promise._getCarriedStackTrace()
              );
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
            if (!shouldNotMarkOriginatingFromRejection) {
              util.markAsOriginatingFromRejection(reason);
            }
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason, hasStack ? void 0 : trace);
          };
          Promise2.prototype._resolveFromResolver = function(resolver) {
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = tryCatch2(resolver)(function(value) {
              if (promise === null)
                return;
              promise._resolveCallback(value);
              promise = null;
            }, function(reason) {
              if (promise === null)
                return;
              promise._rejectCallback(reason, synchronous);
              promise = null;
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0 && r === errorObj2 && promise !== null) {
              promise._rejectCallback(r.e, true, true);
              promise = null;
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
            if (promise._isRejected())
              return;
            promise._pushContext();
            var x;
            if (receiver === APPLY && !this._isRejected()) {
              x = tryCatch2(handler).apply(this._boundValue(), value);
            } else {
              x = tryCatch2(handler).call(receiver, value);
            }
            promise._popContext();
            if (x === errorObj2 || x === promise || x === NEXT_FILTER) {
              var err = x === promise ? makeSelfResolutionError() : x.e;
              promise._rejectCallback(err, false, true);
            } else {
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._cleanValues = function() {
            if (this._cancellable()) {
              this._cancellationParent = void 0;
            }
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            if ((flags & 1) > 0 && parent._cancellable()) {
              this._setCancellable();
              this._cancellationParent = parent;
            }
            if ((flags & 4) > 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          };
          Promise2.prototype._fulfill = function(value) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._fulfillUnchecked(value);
          };
          Promise2.prototype._reject = function(reason, carriedStackTrace) {
            if (this._isFollowingOrFulfilledOrRejected())
              return;
            this._rejectUnchecked(reason, carriedStackTrace);
          };
          Promise2.prototype._settlePromiseAt = function(index) {
            var promise = this._promiseAt(index);
            var isPromise = promise instanceof Promise2;
            if (isPromise && promise._isMigrated()) {
              promise._unsetIsMigrated();
              return async.invoke(this._settlePromiseAt, this, index);
            }
            var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
            var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : void 0;
            var value = this._settledValue;
            var receiver = this._receiverAt(index);
            this._clearCallbackDataAtIndex(index);
            if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
              }
            } else if (receiver instanceof PromiseArray) {
              if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                  receiver._promiseFulfilled(value, promise);
                } else {
                  receiver._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (this._isFulfilled()) {
                promise._fulfill(value);
              } else {
                promise._reject(value, carriedStackTrace);
              }
            }
            if (index >= 4 && (index & 31) === 4)
              async.invokeLater(this._setLength, this, 0);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            if (index === 0) {
              if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = void 0;
              }
              this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = void 0;
            } else {
              var base = index * 5 - 5;
              this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = void 0;
            }
          };
          Promise2.prototype._isSettlePromisesQueued = function() {
            return (this._bitField & -1073741824) === -1073741824;
          };
          Promise2.prototype._setSettlePromisesQueued = function() {
            this._bitField = this._bitField | -1073741824;
          };
          Promise2.prototype._unsetSettlePromisesQueued = function() {
            this._bitField = this._bitField & ~-1073741824;
          };
          Promise2.prototype._queueSettlePromises = function() {
            async.settlePromises(this);
            this._setSettlePromisesQueued();
          };
          Promise2.prototype._fulfillUnchecked = function(value) {
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err, void 0);
            }
            this._setFulfilled();
            this._settledValue = value;
            this._cleanValues();
            if (this._length() > 0) {
              this._queueSettlePromises();
            }
          };
          Promise2.prototype._rejectUncheckedCheckError = function(reason) {
            var trace = util.ensureErrorObject(reason);
            this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
          };
          Promise2.prototype._rejectUnchecked = function(reason, trace) {
            if (reason === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._rejectUnchecked(err);
            }
            this._setRejected();
            this._settledValue = reason;
            this._cleanValues();
            if (this._isFinal()) {
              async.throwLater(function(e) {
                if ("stack" in e) {
                  async.invokeFirst(
                    CapturedTrace.unhandledRejection,
                    void 0,
                    e
                  );
                }
                throw e;
              }, trace === void 0 ? reason : trace);
              return;
            }
            if (trace !== void 0 && trace !== reason) {
              this._setCarriedStackTrace(trace);
            }
            if (this._length() > 0) {
              this._queueSettlePromises();
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._settlePromises = function() {
            this._unsetSettlePromisesQueued();
            var len = this._length();
            for (var i = 0; i < len; i++) {
              this._settlePromiseAt(i);
            }
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./progress.js")(Promise2, PromiseArray);
          _dereq_2("./method.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./bind.js")(Promise2, INTERNAL, tryConvertToPromise);
          _dereq_2("./finally.js")(Promise2, NEXT_FILTER, tryConvertToPromise);
          _dereq_2("./direct_resolve.js")(Promise2);
          _dereq_2("./synchronous_inspection.js")(Promise2);
          _dereq_2("./join.js")(Promise2, PromiseArray, tryConvertToPromise, INTERNAL);
          Promise2.version = "2.11.0";
          Promise2.Promise = Promise2;
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./cancel.js")(Promise2);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
          _dereq_2("./settle.js")(Promise2, PromiseArray);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./timers.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._progressHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
            p._settledValue = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async.js": 2, "./bind.js": 3, "./call_get.js": 5, "./cancel.js": 6, "./captured_trace.js": 7, "./catch_filter.js": 8, "./context.js": 9, "./debuggability.js": 10, "./direct_resolve.js": 11, "./each.js": 12, "./errors.js": 13, "./filter.js": 15, "./finally.js": 16, "./generators.js": 17, "./join.js": 18, "./map.js": 19, "./method.js": 20, "./nodeify.js": 21, "./progress.js": 22, "./promise_array.js": 24, "./promise_resolver.js": 25, "./promisify.js": 26, "./props.js": 27, "./race.js": 29, "./reduce.js": 30, "./settle.js": 32, "./some.js": 33, "./synchronous_inspection.js": 34, "./thenables.js": 35, "./timers.js": 36, "./using.js": 37, "./util.js": 38 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
            }
          }
          function PromiseArray(values) {
            var promise = this._promise = new Promise2(INTERNAL);
            var parent;
            if (values instanceof Promise2) {
              parent = values;
              promise._propagateFrom(parent, 1 | 4);
            }
            this._values = values;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
            var values = tryConvertToPromise(this._values, this._promise);
            if (values instanceof Promise2) {
              values = values._target();
              this._values = values;
              if (values._isFulfilled()) {
                values = values._value();
                if (!isArray(values)) {
                  var err = new Promise2.TypeError("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
                  this.__hardReject__(err);
                  return;
                }
              } else if (values._isPending()) {
                values._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
                return;
              } else {
                this._reject(values._reason());
                return;
              }
            } else if (!isArray(values)) {
              this._promise._reject(apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n")._reason());
              return;
            }
            if (values.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            var len = this.getActualLength(values.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var promise = this._promise;
            for (var i = 0; i < len; ++i) {
              var isResolved = this._isResolved();
              var maybePromise = tryConvertToPromise(values[i], promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                  maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                  maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  this._promiseFulfilled(maybePromise._value(), i);
                } else {
                  this._promiseRejected(maybePromise._reason(), i);
                }
              } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
              }
            }
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false, true);
          };
          PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
            this._promise._progress({
              index,
              value: progressValue
            });
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          PromiseArray.prototype._promiseRejected = function(reason, index) {
            this._totalResolved++;
            this._reject(reason);
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util.js": 38 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util.js");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors.js");
        var TimeoutError = errors.TimeoutError;
        var OperationalError = errors.OperationalError;
        var haveGetters2 = util.haveGetters;
        var es52 = _dereq_2("./es5.js");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys = es52.keys(obj2);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (arguments.length > 2) {
              var $_len = arguments.length;
              var args = new Array($_len - 1);
              for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
              }
              promise._fulfill(args);
            } else {
              promise._fulfill(value);
            }
            promise = null;
          };
        }
        var PromiseResolver;
        if (!haveGetters2) {
          PromiseResolver = function(promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
          };
        } else {
          PromiseResolver = function(promise) {
            this.promise = promise;
          };
        }
        if (haveGetters2) {
          var prop = {
            get: function() {
              return nodebackForPromise(this.promise);
            }
          };
          es52.defineProperty(PromiseResolver.prototype, "asCallback", prop);
          es52.defineProperty(PromiseResolver.prototype, "callback", prop);
        }
        PromiseResolver._nodebackForPromise = nodebackForPromise;
        PromiseResolver.prototype.toString = function() {
          return "[object PromiseResolver]";
        };
        PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._resolveCallback(value);
        };
        PromiseResolver.prototype.reject = function(reason) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._rejectCallback(reason);
        };
        PromiseResolver.prototype.progress = function(value) {
          if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n");
          }
          this.promise._progress(value);
        };
        PromiseResolver.prototype.cancel = function(err) {
          this.promise.cancel(err);
        };
        PromiseResolver.prototype.timeout = function() {
          this.reject(new TimeoutError("timeout"));
        };
        PromiseResolver.prototype.isResolved = function() {
          return this.promise.isResolved();
        };
        PromiseResolver.prototype.toJSON = function() {
          return this.promise.toJSON();
        };
        module2.exports = PromiseResolver;
      }, { "./errors.js": 13, "./es5.js": 14, "./util.js": 38 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util.js");
          var nodebackForPromise = _dereq_2("./promise_resolver.js")._nodebackForPromise;
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
            var keys = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              var value = obj2[key];
              var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ".replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode)
              )(
                Promise2,
                fn,
                receiver,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver, _, fn) {
            var defaultThis = function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver;
              if (receiver === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise);
              try {
                cb.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter, promisifier) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              if (promisifier === makeNodePromisified) {
                obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix);
              } else {
                var promisified = promisifier(fn, function() {
                  return makeNodePromisified(key, THIS, key, fn, suffix);
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj2[promisifiedKey] = promisified;
              }
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver) {
            return makeNodePromisified(callback, receiver, void 0, callback);
          }
          Promise2.promisify = function(fn, receiver) {
            if (typeof fn !== "function") {
              throw new TypeError2("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            }
            if (isPromisified(fn)) {
              return fn;
            }
            var ret2 = promisify(fn, arguments.length < 2 ? THIS : receiver);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n");
            }
            options = Object(options);
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter = options.filter;
            if (typeof filter !== "function")
              filter = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n");
            }
            var keys = util.inheritedDataKeys(target);
            for (var i = 0; i < keys.length; ++i) {
              var value = target[keys[i]];
              if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier);
                promisifyAll(value, suffix, filter, promisifier);
              }
            }
            return promisifyAll(target, suffix, filter, promisifier);
          };
        };
      }, { "./errors": 13, "./promise_resolver.js": 25, "./util.js": 38 }], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util.js");
          var isObject2 = util.isObject;
          var es52 = _dereq_2("./es5.js");
          function PropertiesPromiseArray(obj2) {
            var keys = es52.keys(obj2);
            var len = keys.length;
            var values = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
              var key = keys[i];
              values[i] = obj2[key];
              values[i + len] = key;
            }
            this.constructor$(values);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
            this._init$(void 0, -3);
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val = {};
              var keyOffset = this.length();
              for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
              }
              this._resolve(val);
            }
          };
          PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
            this._promise._progress({
              key: this._values[index + this.length()],
              value
            });
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject2(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 4);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5.js": 14, "./util.js": 38 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size) {
          return this._capacity < size;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype._unshiftOne = function(value) {
          var capacity = this._capacity;
          this._checkCapacity(this.length() + 1);
          var front = this._front;
          var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
          this[i] = value;
          this._front = i;
          this._length = this.length() + 1;
        };
        Queue.prototype.unshift = function(fn, receiver, arg) {
          this._unshiftOne(arg);
          this._unshiftOne(receiver);
          this._unshiftOne(fn);
        };
        Queue.prototype.push = function(fn, receiver, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size) {
          if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var isArray = _dereq_2("./util.js").isArray;
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else if (!isArray(promises)) {
              return apiRejection("expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n");
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 4 | 1);
            }
            var fulfill = ret2._fulfill;
            var reject = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util.js": 38 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
          var getDomain = Promise2._getDomain;
          var async = _dereq_2("./async.js");
          var util = _dereq_2("./util.js");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function ReductionPromiseArray(promises, fn, accum, _each) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            this._preservedValues = _each === INTERNAL ? [] : null;
            this._zerothIsAccum = accum === void 0;
            this._gotAccum = false;
            this._reducingIndex = this._zerothIsAccum ? 1 : 0;
            this._valuesPhase = void 0;
            var maybePromise = tryConvertToPromise(accum, this._promise);
            var rejected = false;
            var isPromise = maybePromise instanceof Promise2;
            if (isPromise) {
              maybePromise = maybePromise._target();
              if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
              } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
              } else {
                this._reject(maybePromise._reason());
                rejected = true;
              }
            }
            if (!(isPromise || this._zerothIsAccum))
              this._gotAccum = true;
            var domain = getDomain();
            this._callback = domain === null ? fn : domain.bind(fn);
            this._accum = accum;
            if (!rejected)
              async.invoke(init, this, void 0);
          }
          function init() {
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            if (this._gotAccum || this._zerothIsAccum) {
              this._resolve(this._preservedValues !== null ? [] : this._accum);
            }
          };
          ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values = this._values;
            values[index] = value;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var isEach = preservedValues !== null;
            var gotAccum = this._gotAccum;
            var valuesPhase = this._valuesPhase;
            var valuesPhaseIndex;
            if (!valuesPhase) {
              valuesPhase = this._valuesPhase = new Array(length);
              for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
              }
            }
            valuesPhaseIndex = valuesPhase[index];
            if (index === 0 && this._zerothIsAccum) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
              valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;
            } else if (index === -1) {
              this._accum = value;
              this._gotAccum = gotAccum = true;
            } else {
              if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
              } else {
                valuesPhase[index] = 2;
                this._accum = value;
              }
            }
            if (!gotAccum)
              return;
            var callback = this._callback;
            var receiver = this._promise._boundValue();
            var ret2;
            for (var i = this._reducingIndex; i < length; ++i) {
              valuesPhaseIndex = valuesPhase[i];
              if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
              }
              if (valuesPhaseIndex !== 1)
                return;
              value = values[i];
              this._promise._pushContext();
              if (isEach) {
                preservedValues.push(value);
                ret2 = tryCatch2(callback).call(receiver, value, i, length);
              } else {
                ret2 = tryCatch2(callback).call(receiver, this._accum, value, i, length);
              }
              this._promise._popContext();
              if (ret2 === errorObj2)
                return this._reject(ret2.e);
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  valuesPhase[i] = 4;
                  return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                  ret2 = maybePromise._value();
                } else {
                  return this._reject(maybePromise._reason());
                }
              }
              this._reducingIndex = i + 1;
              this._accum = ret2;
            }
            this._resolve(isEach ? preservedValues : this._accum);
          };
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
        };
      }, { "./async.js": 2, "./util.js": 38 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        var schedule;
        var util = _dereq_2("./util");
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/m3OTXk\n");
        };
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = global.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
          schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, { attributes: true });
            return function() {
              div.classList.toggle("foo");
            };
          };
          schedule.isStatic = true;
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 38 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util.js");
          function SettledPromiseArray(values) {
            this.constructor$(values);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
            }
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 268435456;
            ret2._settledValue = value;
            this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 134217728;
            ret2._settledValue = reason;
            this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return new SettledPromiseArray(this).promise();
          };
        };
      }, { "./util.js": 38 }], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util.js");
          var RangeError2 = _dereq_2("./errors.js").RangeError;
          var AggregateError = _dereq_2("./errors.js").AggregateError;
          var isArray = util.isArray;
          function SomePromiseArray(values) {
            this.constructor$(values);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
            }
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
              }
              this._reject(e);
            }
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValue = promise._settledValue;
            } else {
              this._bitField = 0;
              this._settledValue = void 0;
            }
          }
          PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            return this._settledValue;
          };
          PromiseInspection.prototype.isFulfilled = Promise2.prototype._isFulfilled = function() {
            return (this._bitField & 268435456) > 0;
          };
          PromiseInspection.prototype.isRejected = Promise2.prototype._isRejected = function() {
            return (this._bitField & 134217728) > 0;
          };
          PromiseInspection.prototype.isPending = Promise2.prototype._isPending = function() {
            return (this._bitField & 402653184) === 0;
          };
          PromiseInspection.prototype.isResolved = Promise2.prototype._isResolved = function() {
            return (this._bitField & 402653184) > 0;
          };
          Promise2.prototype.isPending = function() {
            return this._target()._isPending();
          };
          Promise2.prototype.isRejected = function() {
            return this._target()._isRejected();
          };
          Promise2.prototype.isFulfilled = function() {
            return this._target()._isFulfilled();
          };
          Promise2.prototype.isResolved = function() {
            return this._target()._isResolved();
          };
          Promise2.prototype._value = function() {
            return this._settledValue;
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue;
          };
          Promise2.prototype.value = function() {
            var target = this._target();
            if (!target.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n");
            }
            return target._settledValue;
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            if (!target.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n");
            }
            target._unsetRejectionIsUnhandled();
            return target._settledValue;
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var errorObj2 = util.errorObj;
          var isObject2 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject2(obj2)) {
              if (obj2 instanceof Promise2) {
                return obj2;
              } else if (isAnyBluebirdPromise(obj2)) {
                var ret2 = new Promise2(INTERNAL);
                obj2._then(
                  ret2._fulfillUnchecked,
                  ret2._rejectUncheckedCheckError,
                  ret2._progressUnchecked,
                  ret2,
                  null
                );
                return ret2;
              }
              var then = util.tryCatch(getThen)(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function getThen(obj2) {
            return obj2.then;
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            return hasProp.call(obj2, "_promise0");
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result = util.tryCatch(then).call(
              x,
              resolveFromThenable,
              rejectFromThenable,
              progressFromThenable
            );
            synchronous = false;
            if (promise && result === errorObj2) {
              promise._rejectCallback(result.e, true, true);
              promise = null;
            }
            function resolveFromThenable(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function rejectFromThenable(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            function progressFromThenable(value) {
              if (!promise)
                return;
              if (typeof promise._progress === "function") {
                promise._progress(value);
              }
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util.js": 38 }], 36: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util.js");
          var TimeoutError = Promise2.TimeoutError;
          var afterTimeout = function(promise, message) {
            if (!promise.isPending())
              return;
            var err;
            if (!util.isPrimitive(message) && message instanceof Error) {
              err = message;
            } else {
              if (typeof message !== "string") {
                message = "operation timed out";
              }
              err = new TimeoutError(message);
            }
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._cancel(err);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(value, ms) {
            if (ms === void 0) {
              ms = value;
              value = void 0;
              var ret2 = new Promise2(INTERNAL);
              setTimeout(function() {
                ret2._fulfill();
              }, ms);
              return ret2;
            }
            ms = +ms;
            return Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          };
          Promise2.prototype.delay = function(ms) {
            return delay(this, ms);
          };
          function successClear(value) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            return value;
          }
          function failureClear(reason) {
            var handle = this;
            if (handle instanceof Number)
              handle = +handle;
            clearTimeout(handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2 = this.then().cancellable();
            ret2._cancellationParent = this;
            var handle = setTimeout(function timeoutTimeout() {
              afterTimeout(ret2, message);
            }, ms);
            return ret2._then(successClear, failureClear, void 0, handle, void 0);
          };
        };
      }, { "./util.js": 38 }], 37: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext) {
          var TypeError2 = _dereq_2("./errors.js").TypeError;
          var inherits2 = _dereq_2("./util.js").inherits;
          var PromiseInspection = Promise2.PromiseInspection;
          function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
              var inspection = inspections[i];
              if (inspection.isRejected()) {
                return Promise2.reject(inspection.error());
              }
              inspections[i] = inspection._settledValue;
            }
            return inspections;
          }
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = Promise2.defer();
            function iterator() {
              if (i >= len)
                return ret2.resolve();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2.promise;
          }
          function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
          }
          function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return null;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== null ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function")
              return apiRejection("fn must be a function\n\n    See http://goo.gl/916lJJ\n");
            var input;
            var spreadArgs = true;
            if (len === 2 && Array.isArray(arguments[0])) {
              input = arguments[0];
              len = input.length;
              spreadArgs = false;
            } else {
              input = arguments;
              len--;
            }
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
              var resource = input[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var promise = Promise2.settle(resources).then(inspectionMapper).then(function(vals) {
              promise._pushContext();
              var ret2;
              try {
                ret2 = spreadArgs ? fn.apply(void 0, vals) : fn.call(void 0, vals);
              } finally {
                promise._popContext();
              }
              return ret2;
            })._then(
              disposerSuccess,
              disposerFail,
              void 0,
              resources,
              void 0
            );
            resources.promise = promise;
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~262144;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors.js": 13, "./util.js": 38 }], 38: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5.js");
        var canEvaluate = typeof navigator == "undefined";
        var haveGetters = function() {
          try {
            var o = {};
            es5.defineProperty(o, "f", {
              get: function() {
                return 3;
              }
            });
            return o.f === 3;
          } catch (e) {
            return false;
          }
        }();
        var errorObj = { e: {} };
        var tryCatchTarget;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return !isPrimitive(value);
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys;
                try {
                  keys = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys.length > 1;
              var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function f() {
          }
          f.prototype = obj;
          var l = 8;
          while (l--)
            new f();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return obj2 instanceof Error && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter) {
          var keys = es5.names(from);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var ret = {
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          haveGetters,
          notEnumerableProp,
          isPrimitive,
          isObject,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
          isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
        };
        ret.isRecentNode = ret.isNode && function() {
          var version = process.versions.node.split(".").map(Number);
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5.js": 14 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// node_modules/node-wordnet/node_modules/lru-cache/lib/lru-cache.js
var require_lru_cache = __commonJS({
  "node_modules/node-wordnet/node_modules/lru-cache/lib/lru-cache.js"(exports2, module2) {
    (function() {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = LRUCache;
      } else {
        this.LRUCache = LRUCache;
      }
      function hOP(obj2, key) {
        return Object.prototype.hasOwnProperty.call(obj2, key);
      }
      function naiveLength() {
        return 1;
      }
      var didTypeWarning = false;
      function typeCheckKey(key) {
        if (!didTypeWarning && typeof key !== "string" && typeof key !== "number") {
          didTypeWarning = true;
          console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack);
        }
      }
      function LRUCache(options) {
        if (!(this instanceof LRUCache))
          return new LRUCache(options);
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        this._max = options.max;
        if (!this._max || !(typeof this._max === "number") || this._max <= 0)
          this._max = Infinity;
        this._lengthCalculator = options.length || naiveLength;
        if (typeof this._lengthCalculator !== "function")
          this._lengthCalculator = naiveLength;
        this._allowStale = options.stale || false;
        this._maxAge = options.maxAge || null;
        this._dispose = options.dispose;
        this.reset();
      }
      Object.defineProperty(
        LRUCache.prototype,
        "max",
        {
          set: function(mL) {
            if (!mL || !(typeof mL === "number") || mL <= 0)
              mL = Infinity;
            this._max = mL;
            if (this._length > this._max)
              trim(this);
          },
          get: function() {
            return this._max;
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        LRUCache.prototype,
        "lengthCalculator",
        {
          set: function(lC) {
            if (typeof lC !== "function") {
              this._lengthCalculator = naiveLength;
              this._length = this._itemCount;
              for (var key in this._cache) {
                this._cache[key].length = 1;
              }
            } else {
              this._lengthCalculator = lC;
              this._length = 0;
              for (var key in this._cache) {
                this._cache[key].length = this._lengthCalculator(this._cache[key].value);
                this._length += this._cache[key].length;
              }
            }
            if (this._length > this._max)
              trim(this);
          },
          get: function() {
            return this._lengthCalculator;
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        LRUCache.prototype,
        "length",
        {
          get: function() {
            return this._length;
          },
          enumerable: true
        }
      );
      Object.defineProperty(
        LRUCache.prototype,
        "itemCount",
        {
          get: function() {
            return this._itemCount;
          },
          enumerable: true
        }
      );
      LRUCache.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        var i = 0;
        var itemCount = this._itemCount;
        for (var k = this._mru - 1; k >= 0 && i < itemCount; k--)
          if (this._lruList[k]) {
            i++;
            var hit = this._lruList[k];
            if (isStale(this, hit)) {
              del(this, hit);
              if (!this._allowStale)
                hit = void 0;
            }
            if (hit) {
              fn.call(thisp, hit.value, hit.key, this);
            }
          }
      };
      LRUCache.prototype.keys = function() {
        var keys = new Array(this._itemCount);
        var i = 0;
        for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
          if (this._lruList[k]) {
            var hit = this._lruList[k];
            keys[i++] = hit.key;
          }
        return keys;
      };
      LRUCache.prototype.values = function() {
        var values = new Array(this._itemCount);
        var i = 0;
        for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
          if (this._lruList[k]) {
            var hit = this._lruList[k];
            values[i++] = hit.value;
          }
        return values;
      };
      LRUCache.prototype.reset = function() {
        if (this._dispose && this._cache) {
          for (var k in this._cache) {
            this._dispose(k, this._cache[k].value);
          }
        }
        this._cache = /* @__PURE__ */ Object.create(null);
        this._lruList = /* @__PURE__ */ Object.create(null);
        this._mru = 0;
        this._lru = 0;
        this._length = 0;
        this._itemCount = 0;
      };
      LRUCache.prototype.dump = function() {
        var arr = [];
        var i = 0;
        for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
          if (this._lruList[k]) {
            var hit = this._lruList[k];
            if (!isStale(this, hit)) {
              ++i;
              arr.push({
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
              });
            }
          }
        return arr;
      };
      LRUCache.prototype.dumpLru = function() {
        return this._lruList;
      };
      LRUCache.prototype.set = function(key, value, maxAge) {
        maxAge = maxAge || this._maxAge;
        typeCheckKey(key);
        var now = maxAge ? Date.now() : 0;
        var len = this._lengthCalculator(value);
        if (hOP(this._cache, key)) {
          if (len > this._max) {
            del(this, this._cache[key]);
            return false;
          }
          if (this._dispose)
            this._dispose(key, this._cache[key].value);
          this._cache[key].now = now;
          this._cache[key].maxAge = maxAge;
          this._cache[key].value = value;
          this._length += len - this._cache[key].length;
          this._cache[key].length = len;
          this.get(key);
          if (this._length > this._max)
            trim(this);
          return true;
        }
        var hit = new Entry(key, value, this._mru++, len, now, maxAge);
        if (hit.length > this._max) {
          if (this._dispose)
            this._dispose(key, value);
          return false;
        }
        this._length += hit.length;
        this._lruList[hit.lu] = this._cache[key] = hit;
        this._itemCount++;
        if (this._length > this._max)
          trim(this);
        return true;
      };
      LRUCache.prototype.has = function(key) {
        typeCheckKey(key);
        if (!hOP(this._cache, key))
          return false;
        var hit = this._cache[key];
        if (isStale(this, hit)) {
          return false;
        }
        return true;
      };
      LRUCache.prototype.get = function(key) {
        typeCheckKey(key);
        return get(this, key, true);
      };
      LRUCache.prototype.peek = function(key) {
        typeCheckKey(key);
        return get(this, key, false);
      };
      LRUCache.prototype.pop = function() {
        var hit = this._lruList[this._lru];
        del(this, hit);
        return hit || null;
      };
      LRUCache.prototype.del = function(key) {
        typeCheckKey(key);
        del(this, this._cache[key]);
      };
      LRUCache.prototype.load = function(arr) {
        this.reset();
        var now = Date.now();
        for (var l2 = arr.length - 1; l2 >= 0; l2--) {
          var hit = arr[l2];
          typeCheckKey(hit.k);
          var expiresAt = hit.e || 0;
          if (expiresAt === 0) {
            this.set(hit.k, hit.v);
          } else {
            var maxAge = expiresAt - now;
            if (maxAge > 0)
              this.set(hit.k, hit.v, maxAge);
          }
        }
      };
      function get(self2, key, doUse) {
        typeCheckKey(key);
        var hit = self2._cache[key];
        if (hit) {
          if (isStale(self2, hit)) {
            del(self2, hit);
            if (!self2._allowStale)
              hit = void 0;
          } else {
            if (doUse)
              use(self2, hit);
          }
          if (hit)
            hit = hit.value;
        }
        return hit;
      }
      function isStale(self2, hit) {
        if (!hit || !hit.maxAge && !self2._maxAge)
          return false;
        var stale = false;
        var diff = Date.now() - hit.now;
        if (hit.maxAge) {
          stale = diff > hit.maxAge;
        } else {
          stale = self2._maxAge && diff > self2._maxAge;
        }
        return stale;
      }
      function use(self2, hit) {
        shiftLU(self2, hit);
        hit.lu = self2._mru++;
        self2._lruList[hit.lu] = hit;
      }
      function trim(self2) {
        while (self2._lru < self2._mru && self2._length > self2._max)
          del(self2, self2._lruList[self2._lru]);
      }
      function shiftLU(self2, hit) {
        delete self2._lruList[hit.lu];
        while (self2._lru < self2._mru && !self2._lruList[self2._lru])
          self2._lru++;
      }
      function del(self2, hit) {
        if (hit) {
          if (self2._dispose)
            self2._dispose(hit.key, hit.value);
          self2._length -= hit.length;
          self2._itemCount--;
          delete self2._cache[hit.key];
          shiftLU(self2, hit);
        }
      }
      function Entry(key, value, lu, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.lu = lu;
        this.length = length;
        this.now = now;
        if (maxAge)
          this.maxAge = maxAge;
      }
    })();
  }
});

// node_modules/es6-shim/es6-shim.js
var require_es6_shim = __commonJS({
  "node_modules/es6-shim/es6-shim.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory();
      } else {
        root.returnExports = factory();
      }
    })(exports2, function() {
      "use strict";
      var isCallableWithoutNew = function(func) {
        try {
          func();
        } catch (e) {
          return false;
        }
        return true;
      };
      var supportsSubclassing = function(C, f2) {
        try {
          var Sub = function() {
            C.apply(this, arguments);
          };
          if (!Sub.__proto__) {
            return false;
          }
          Object.setPrototypeOf(Sub, C);
          Sub.prototype = Object.create(C.prototype, {
            constructor: { value: C }
          });
          return f2(Sub);
        } catch (e) {
          return false;
        }
      };
      var arePropertyDescriptorsSupported = function() {
        try {
          Object.defineProperty({}, "x", {});
          return true;
        } catch (e) {
          return false;
        }
      };
      var startsWithRejectsRegex = function() {
        var rejectsRegex = false;
        if (String.prototype.startsWith) {
          try {
            "/a/".startsWith(/a/);
          } catch (e) {
            rejectsRegex = true;
          }
        }
        return rejectsRegex;
      };
      var getGlobal = new Function("return this;");
      var globals = getGlobal();
      var global_isFinite = globals.isFinite;
      var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
      var startsWithIsCompliant = startsWithRejectsRegex();
      var _indexOf = Function.call.bind(String.prototype.indexOf);
      var _toString = Function.call.bind(Object.prototype.toString);
      var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      var ArrayIterator;
      var noop = function() {
      };
      var Symbol = globals.Symbol || {};
      var Type = {
        string: function(x) {
          return _toString(x) === "[object String]";
        },
        regex: function(x) {
          return _toString(x) === "[object RegExp]";
        },
        symbol: function(x) {
          return typeof globals.Symbol === "function" && typeof x === "symbol";
        }
      };
      var defineProperty = function(object, name, value, force) {
        if (!force && name in object) {
          return;
        }
        if (supportsDescriptors) {
          Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value
          });
        } else {
          object[name] = value;
        }
      };
      var Value = {
        getter: function(object, name, getter) {
          if (!supportsDescriptors) {
            throw new TypeError("getters require true ES5 support");
          }
          Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            get: getter
          });
        },
        proxy: function(originalObject, key, targetObject) {
          if (!supportsDescriptors) {
            throw new TypeError("getters require true ES5 support");
          }
          var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
          Object.defineProperty(targetObject, key, {
            configurable: originalDescriptor.configurable,
            enumerable: originalDescriptor.enumerable,
            get: function getKey() {
              return originalObject[key];
            },
            set: function setKey(value) {
              originalObject[key] = value;
            }
          });
        },
        redefine: function(object, property, newValue) {
          if (supportsDescriptors) {
            var descriptor = Object.getOwnPropertyDescriptor(object, property);
            descriptor.value = newValue;
            Object.defineProperty(object, property, descriptor);
          } else {
            object[property] = newValue;
          }
        }
      };
      var defineProperties = function(object, map) {
        Object.keys(map).forEach(function(name) {
          var method = map[name];
          defineProperty(object, name, method, false);
        });
      };
      var create = Object.create || function(prototype, properties) {
        function Prototype() {
        }
        Prototype.prototype = prototype;
        var object = new Prototype();
        if (typeof properties !== "undefined") {
          defineProperties(object, properties);
        }
        return object;
      };
      var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : "_es6-shim iterator_";
      if (globals.Set && typeof new globals.Set()["@@iterator"] === "function") {
        $iterator$ = "@@iterator";
      }
      var addIterator = function(prototype, impl) {
        if (!impl) {
          impl = function iterator() {
            return this;
          };
        }
        var o = {};
        o[$iterator$] = impl;
        defineProperties(prototype, o);
        if (!prototype[$iterator$] && Type.symbol($iterator$)) {
          prototype[$iterator$] = impl;
        }
      };
      var isArguments = function isArguments2(value) {
        var str = _toString(value);
        var result = str === "[object Arguments]";
        if (!result) {
          result = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && _toString(value.callee) === "[object Function]";
        }
        return result;
      };
      var ES = {
        CheckObjectCoercible: function(x, optMessage) {
          if (x == null) {
            throw new TypeError(optMessage || "Cannot call method on " + x);
          }
          return x;
        },
        TypeIsObject: function(x) {
          return x != null && Object(x) === x;
        },
        ToObject: function(o, optMessage) {
          return Object(ES.CheckObjectCoercible(o, optMessage));
        },
        IsCallable: function(x) {
          return typeof x === "function" && _toString(x) === "[object Function]";
        },
        ToInt32: function(x) {
          return ES.ToNumber(x) >> 0;
        },
        ToUint32: function(x) {
          return ES.ToNumber(x) >>> 0;
        },
        ToNumber: function(value) {
          if (_toString(value) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
          }
          return +value;
        },
        ToInteger: function(value) {
          var number = ES.ToNumber(value);
          if (Number.isNaN(number)) {
            return 0;
          }
          if (number === 0 || !Number.isFinite(number)) {
            return number;
          }
          return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
        },
        ToLength: function(value) {
          var len = ES.ToInteger(value);
          if (len <= 0) {
            return 0;
          }
          if (len > Number.MAX_SAFE_INTEGER) {
            return Number.MAX_SAFE_INTEGER;
          }
          return len;
        },
        SameValue: function(a, b) {
          if (a === b) {
            if (a === 0) {
              return 1 / a === 1 / b;
            }
            return true;
          }
          return Number.isNaN(a) && Number.isNaN(b);
        },
        SameValueZero: function(a, b) {
          return a === b || Number.isNaN(a) && Number.isNaN(b);
        },
        IsIterable: function(o) {
          return ES.TypeIsObject(o) && (typeof o[$iterator$] !== "undefined" || isArguments(o));
        },
        GetIterator: function(o) {
          if (isArguments(o)) {
            return new ArrayIterator(o, "value");
          }
          var itFn = o[$iterator$];
          if (!ES.IsCallable(itFn)) {
            throw new TypeError("value is not an iterable");
          }
          var it = itFn.call(o);
          if (!ES.TypeIsObject(it)) {
            throw new TypeError("bad iterator");
          }
          return it;
        },
        IteratorNext: function(it) {
          var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
          if (!ES.TypeIsObject(result)) {
            throw new TypeError("bad iterator");
          }
          return result;
        },
        Construct: function(C, args) {
          var obj2;
          if (ES.IsCallable(C["@@create"])) {
            obj2 = C["@@create"]();
          } else {
            obj2 = create(C.prototype || null);
          }
          defineProperties(obj2, { _es6construct: true });
          var result = C.apply(obj2, args);
          return ES.TypeIsObject(result) ? result : obj2;
        }
      };
      var emulateES6construct = function(o) {
        if (!ES.TypeIsObject(o)) {
          throw new TypeError("bad object");
        }
        if (!o._es6construct) {
          if (o.constructor && ES.IsCallable(o.constructor["@@create"])) {
            o = o.constructor["@@create"](o);
          }
          defineProperties(o, { _es6construct: true });
        }
        return o;
      };
      var numberConversion = function() {
        function roundToEven(n) {
          var w = Math.floor(n), f2 = n - w;
          if (f2 < 0.5) {
            return w;
          }
          if (f2 > 0.5) {
            return w + 1;
          }
          return w % 2 ? w + 1 : w;
        }
        function packIEEE754(v, ebits, fbits) {
          var bias = (1 << ebits - 1) - 1, s, e, f2, i, bits, str, bytes;
          if (v !== v) {
            e = (1 << ebits) - 1;
            f2 = Math.pow(2, fbits - 1);
            s = 0;
          } else if (v === Infinity || v === -Infinity) {
            e = (1 << ebits) - 1;
            f2 = 0;
            s = v < 0 ? 1 : 0;
          } else if (v === 0) {
            e = 0;
            f2 = 0;
            s = 1 / v === -Infinity ? 1 : 0;
          } else {
            s = v < 0;
            v = Math.abs(v);
            if (v >= Math.pow(2, 1 - bias)) {
              e = Math.min(Math.floor(Math.log(v) / Math.LN2), 1023);
              f2 = roundToEven(v / Math.pow(2, e) * Math.pow(2, fbits));
              if (f2 / Math.pow(2, fbits) >= 2) {
                e = e + 1;
                f2 = 1;
              }
              if (e > bias) {
                e = (1 << ebits) - 1;
                f2 = 0;
              } else {
                e = e + bias;
                f2 = f2 - Math.pow(2, fbits);
              }
            } else {
              e = 0;
              f2 = roundToEven(v / Math.pow(2, 1 - bias - fbits));
            }
          }
          bits = [];
          for (i = fbits; i; i -= 1) {
            bits.push(f2 % 2 ? 1 : 0);
            f2 = Math.floor(f2 / 2);
          }
          for (i = ebits; i; i -= 1) {
            bits.push(e % 2 ? 1 : 0);
            e = Math.floor(e / 2);
          }
          bits.push(s ? 1 : 0);
          bits.reverse();
          str = bits.join("");
          bytes = [];
          while (str.length) {
            bytes.push(parseInt(str.slice(0, 8), 2));
            str = str.slice(8);
          }
          return bytes;
        }
        function unpackIEEE754(bytes, ebits, fbits) {
          var bits = [], i, j, b, str, bias, s, e, f2;
          for (i = bytes.length; i; i -= 1) {
            b = bytes[i - 1];
            for (j = 8; j; j -= 1) {
              bits.push(b % 2 ? 1 : 0);
              b = b >> 1;
            }
          }
          bits.reverse();
          str = bits.join("");
          bias = (1 << ebits - 1) - 1;
          s = parseInt(str.slice(0, 1), 2) ? -1 : 1;
          e = parseInt(str.slice(1, 1 + ebits), 2);
          f2 = parseInt(str.slice(1 + ebits), 2);
          if (e === (1 << ebits) - 1) {
            return f2 !== 0 ? NaN : s * Infinity;
          } else if (e > 0) {
            return s * Math.pow(2, e - bias) * (1 + f2 / Math.pow(2, fbits));
          } else if (f2 !== 0) {
            return s * Math.pow(2, -(bias - 1)) * (f2 / Math.pow(2, fbits));
          } else {
            return s < 0 ? -0 : 0;
          }
        }
        function unpackFloat64(b) {
          return unpackIEEE754(b, 11, 52);
        }
        function packFloat64(v) {
          return packIEEE754(v, 11, 52);
        }
        function unpackFloat32(b) {
          return unpackIEEE754(b, 8, 23);
        }
        function packFloat32(v) {
          return packIEEE754(v, 8, 23);
        }
        var conversions = {
          toFloat32: function(num) {
            return unpackFloat32(packFloat32(num));
          }
        };
        if (typeof Float32Array !== "undefined") {
          var float32array = new Float32Array(1);
          conversions.toFloat32 = function(num) {
            float32array[0] = num;
            return float32array[0];
          };
        }
        return conversions;
      }();
      defineProperties(String, {
        fromCodePoint: function fromCodePoint(codePoints) {
          var result = [];
          var next;
          for (var i = 0, length = arguments.length; i < length; i++) {
            next = Number(arguments[i]);
            if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 1114111) {
              throw new RangeError("Invalid code point " + next);
            }
            if (next < 65536) {
              result.push(String.fromCharCode(next));
            } else {
              next -= 65536;
              result.push(String.fromCharCode((next >> 10) + 55296));
              result.push(String.fromCharCode(next % 1024 + 56320));
            }
          }
          return result.join("");
        },
        raw: function raw(callSite) {
          var cooked = ES.ToObject(callSite, "bad callSite");
          var rawValue = cooked.raw;
          var rawString = ES.ToObject(rawValue, "bad raw value");
          var len = rawString.length;
          var literalsegments = ES.ToLength(len);
          if (literalsegments <= 0) {
            return "";
          }
          var stringElements = [];
          var nextIndex = 0;
          var nextKey, next, nextSeg, nextSub;
          while (nextIndex < literalsegments) {
            nextKey = String(nextIndex);
            next = rawString[nextKey];
            nextSeg = String(next);
            stringElements.push(nextSeg);
            if (nextIndex + 1 >= literalsegments) {
              break;
            }
            next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : "";
            nextSub = String(next);
            stringElements.push(nextSub);
            nextIndex++;
          }
          return stringElements.join("");
        }
      });
      if (String.fromCodePoint.length !== 1) {
        var originalFromCodePoint = Function.apply.bind(String.fromCodePoint);
        defineProperty(String, "fromCodePoint", function fromCodePoint(codePoints) {
          return originalFromCodePoint(this, arguments);
        }, true);
      }
      var StringShims = {
        // Fast repeat, uses the `Exponentiation by squaring` algorithm.
        // Perf: http://jsperf.com/string-repeat2/2
        repeat: function() {
          var repeat = function(s, times) {
            if (times < 1) {
              return "";
            }
            if (times % 2) {
              return repeat(s, times - 1) + s;
            }
            var half = repeat(s, times / 2);
            return half + half;
          };
          return function(times) {
            var thisStr = String(ES.CheckObjectCoercible(this));
            times = ES.ToInteger(times);
            if (times < 0 || times === Infinity) {
              throw new RangeError("Invalid String#repeat value");
            }
            return repeat(thisStr, times);
          };
        }(),
        startsWith: function(searchStr) {
          var thisStr = String(ES.CheckObjectCoercible(this));
          if (Type.regex(searchStr)) {
            throw new TypeError('Cannot call method "startsWith" with a regex');
          }
          searchStr = String(searchStr);
          var startArg = arguments.length > 1 ? arguments[1] : void 0;
          var start = Math.max(ES.ToInteger(startArg), 0);
          return thisStr.slice(start, start + searchStr.length) === searchStr;
        },
        endsWith: function(searchStr) {
          var thisStr = String(ES.CheckObjectCoercible(this));
          if (Type.regex(searchStr)) {
            throw new TypeError('Cannot call method "endsWith" with a regex');
          }
          searchStr = String(searchStr);
          var thisLen = thisStr.length;
          var posArg = arguments.length > 1 ? arguments[1] : void 0;
          var pos = typeof posArg === "undefined" ? thisLen : ES.ToInteger(posArg);
          var end = Math.min(Math.max(pos, 0), thisLen);
          return thisStr.slice(end - searchStr.length, end) === searchStr;
        },
        includes: function includes(searchString) {
          var position = arguments.length > 1 ? arguments[1] : void 0;
          return _indexOf(this, searchString, position) !== -1;
        },
        codePointAt: function(pos) {
          var thisStr = String(ES.CheckObjectCoercible(this));
          var position = ES.ToInteger(pos);
          var length = thisStr.length;
          if (position >= 0 && position < length) {
            var first = thisStr.charCodeAt(position);
            var isEnd = position + 1 === length;
            if (first < 55296 || first > 56319 || isEnd) {
              return first;
            }
            var second = thisStr.charCodeAt(position + 1);
            if (second < 56320 || second > 57343) {
              return first;
            }
            return (first - 55296) * 1024 + (second - 56320) + 65536;
          }
        }
      };
      defineProperties(String.prototype, StringShims);
      var hasStringTrimBug = "".trim().length !== 1;
      if (hasStringTrimBug) {
        delete String.prototype.trim;
        var ws = [
          "	\n\v\f\r ",
          "\u2028",
          "\u2029\uFEFF"
        ].join("");
        var trimRegexp = new RegExp("(^[" + ws + "]+)|([" + ws + "]+$)", "g");
        defineProperties(String.prototype, {
          trim: function() {
            if (typeof this === "undefined" || this === null) {
              throw new TypeError("can't convert " + this + " to object");
            }
            return String(this).replace(trimRegexp, "");
          }
        });
      }
      var StringIterator = function(s) {
        this._s = String(ES.CheckObjectCoercible(s));
        this._i = 0;
      };
      StringIterator.prototype.next = function() {
        var s = this._s, i = this._i;
        if (typeof s === "undefined" || i >= s.length) {
          this._s = void 0;
          return { value: void 0, done: true };
        }
        var first = s.charCodeAt(i), second, len;
        if (first < 55296 || first > 56319 || i + 1 === s.length) {
          len = 1;
        } else {
          second = s.charCodeAt(i + 1);
          len = second < 56320 || second > 57343 ? 1 : 2;
        }
        this._i = i + len;
        return { value: s.substr(i, len), done: false };
      };
      addIterator(StringIterator.prototype);
      addIterator(String.prototype, function() {
        return new StringIterator(this);
      });
      if (!startsWithIsCompliant) {
        defineProperties(String.prototype, {
          startsWith: StringShims.startsWith,
          endsWith: StringShims.endsWith
        });
      }
      var ArrayShims = {
        from: function(iterable) {
          var mapFn = arguments.length > 1 ? arguments[1] : void 0;
          var list = ES.ToObject(iterable, "bad iterable");
          if (typeof mapFn !== "undefined" && !ES.IsCallable(mapFn)) {
            throw new TypeError("Array.from: when provided, the second argument must be a function");
          }
          var hasThisArg = arguments.length > 2;
          var thisArg = hasThisArg ? arguments[2] : void 0;
          var usingIterator = ES.IsIterable(list);
          var length;
          var result, i, value;
          if (usingIterator) {
            i = 0;
            result = ES.IsCallable(this) ? Object(new this()) : [];
            var it = usingIterator ? ES.GetIterator(list) : null;
            var iterationValue;
            do {
              iterationValue = ES.IteratorNext(it);
              if (!iterationValue.done) {
                value = iterationValue.value;
                if (mapFn) {
                  result[i] = hasThisArg ? mapFn.call(thisArg, value, i) : mapFn(value, i);
                } else {
                  result[i] = value;
                }
                i += 1;
              }
            } while (!iterationValue.done);
            length = i;
          } else {
            length = ES.ToLength(list.length);
            result = ES.IsCallable(this) ? Object(new this(length)) : new Array(length);
            for (i = 0; i < length; ++i) {
              value = list[i];
              if (mapFn) {
                result[i] = hasThisArg ? mapFn.call(thisArg, value, i) : mapFn(value, i);
              } else {
                result[i] = value;
              }
            }
          }
          result.length = length;
          return result;
        },
        of: function() {
          return Array.from(arguments);
        }
      };
      defineProperties(Array, ArrayShims);
      var arrayFromSwallowsNegativeLengths = function() {
        try {
          return Array.from({ length: -1 }).length === 0;
        } catch (e) {
          return false;
        }
      };
      if (!arrayFromSwallowsNegativeLengths()) {
        defineProperty(Array, "from", ArrayShims.from, true);
      }
      ArrayIterator = function(array, kind) {
        this.i = 0;
        this.array = array;
        this.kind = kind;
      };
      defineProperties(ArrayIterator.prototype, {
        next: function() {
          var i = this.i, array = this.array;
          if (!(this instanceof ArrayIterator)) {
            throw new TypeError("Not an ArrayIterator");
          }
          if (typeof array !== "undefined") {
            var len = ES.ToLength(array.length);
            for (; i < len; i++) {
              var kind = this.kind;
              var retval;
              if (kind === "key") {
                retval = i;
              } else if (kind === "value") {
                retval = array[i];
              } else if (kind === "entry") {
                retval = [i, array[i]];
              }
              this.i = i + 1;
              return { value: retval, done: false };
            }
          }
          this.array = void 0;
          return { value: void 0, done: true };
        }
      });
      addIterator(ArrayIterator.prototype);
      var ArrayPrototypeShims = {
        copyWithin: function(target, start) {
          var end = arguments[2];
          var o = ES.ToObject(this);
          var len = ES.ToLength(o.length);
          target = ES.ToInteger(target);
          start = ES.ToInteger(start);
          var to = target < 0 ? Math.max(len + target, 0) : Math.min(target, len);
          var from = start < 0 ? Math.max(len + start, 0) : Math.min(start, len);
          end = typeof end === "undefined" ? len : ES.ToInteger(end);
          var fin = end < 0 ? Math.max(len + end, 0) : Math.min(end, len);
          var count = Math.min(fin - from, len - to);
          var direction = 1;
          if (from < to && to < from + count) {
            direction = -1;
            from += count - 1;
            to += count - 1;
          }
          while (count > 0) {
            if (_hasOwnProperty(o, from)) {
              o[to] = o[from];
            } else {
              delete o[from];
            }
            from += direction;
            to += direction;
            count -= 1;
          }
          return o;
        },
        fill: function(value) {
          var start = arguments.length > 1 ? arguments[1] : void 0;
          var end = arguments.length > 2 ? arguments[2] : void 0;
          var O = ES.ToObject(this);
          var len = ES.ToLength(O.length);
          start = ES.ToInteger(typeof start === "undefined" ? 0 : start);
          end = ES.ToInteger(typeof end === "undefined" ? len : end);
          var relativeStart = start < 0 ? Math.max(len + start, 0) : Math.min(start, len);
          var relativeEnd = end < 0 ? len + end : end;
          for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
            O[i] = value;
          }
          return O;
        },
        find: function find(predicate) {
          var list = ES.ToObject(this);
          var length = ES.ToLength(list.length);
          if (!ES.IsCallable(predicate)) {
            throw new TypeError("Array#find: predicate must be a function");
          }
          var thisArg = arguments.length > 1 ? arguments[1] : null;
          for (var i = 0, value; i < length; i++) {
            value = list[i];
            if (thisArg) {
              if (predicate.call(thisArg, value, i, list)) {
                return value;
              }
            } else if (predicate(value, i, list)) {
              return value;
            }
          }
        },
        findIndex: function findIndex(predicate) {
          var list = ES.ToObject(this);
          var length = ES.ToLength(list.length);
          if (!ES.IsCallable(predicate)) {
            throw new TypeError("Array#findIndex: predicate must be a function");
          }
          var thisArg = arguments.length > 1 ? arguments[1] : null;
          for (var i = 0; i < length; i++) {
            if (thisArg) {
              if (predicate.call(thisArg, list[i], i, list)) {
                return i;
              }
            } else if (predicate(list[i], i, list)) {
              return i;
            }
          }
          return -1;
        },
        keys: function() {
          return new ArrayIterator(this, "key");
        },
        values: function() {
          return new ArrayIterator(this, "value");
        },
        entries: function() {
          return new ArrayIterator(this, "entry");
        }
      };
      if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
        delete Array.prototype.keys;
      }
      if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
        delete Array.prototype.entries;
      }
      if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
        defineProperties(Array.prototype, {
          values: Array.prototype[$iterator$]
        });
        if (Type.symbol(Symbol.unscopables)) {
          Array.prototype[Symbol.unscopables].values = true;
        }
      }
      defineProperties(Array.prototype, ArrayPrototypeShims);
      addIterator(Array.prototype, function() {
        return this.values();
      });
      if (Object.getPrototypeOf) {
        addIterator(Object.getPrototypeOf([].values()));
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      defineProperties(Number, {
        MAX_SAFE_INTEGER: maxSafeInteger,
        MIN_SAFE_INTEGER: -maxSafeInteger,
        EPSILON: 2220446049250313e-31,
        parseInt: globals.parseInt,
        parseFloat: globals.parseFloat,
        isFinite: function(value) {
          return typeof value === "number" && global_isFinite(value);
        },
        isInteger: function(value) {
          return Number.isFinite(value) && ES.ToInteger(value) === value;
        },
        isSafeInteger: function(value) {
          return Number.isInteger(value) && Math.abs(value) <= Number.MAX_SAFE_INTEGER;
        },
        isNaN: function(value) {
          return value !== value;
        }
      });
      if (![, 1].find(function(item, idx) {
        return idx === 0;
      })) {
        defineProperty(Array.prototype, "find", ArrayPrototypeShims.find, true);
      }
      if ([, 1].findIndex(function(item, idx) {
        return idx === 0;
      }) !== 0) {
        defineProperty(Array.prototype, "findIndex", ArrayPrototypeShims.findIndex, true);
      }
      if (supportsDescriptors) {
        defineProperties(Object, {
          // 19.1.3.1
          assign: function(target, source) {
            if (!ES.TypeIsObject(target)) {
              throw new TypeError("target must be an object");
            }
            return Array.prototype.reduce.call(arguments, function(target2, source2) {
              return Object.keys(Object(source2)).reduce(function(target3, key) {
                target3[key] = source2[key];
                return target3;
              }, target2);
            });
          },
          is: function(a, b) {
            return ES.SameValue(a, b);
          },
          // 19.1.3.9
          // shim from https://gist.github.com/WebReflection/5593554
          setPrototypeOf: function(Object2, magic) {
            var set;
            var checkArgs = function(O, proto) {
              if (!ES.TypeIsObject(O)) {
                throw new TypeError("cannot set prototype on a non-object");
              }
              if (!(proto === null || ES.TypeIsObject(proto))) {
                throw new TypeError("can only set prototype to an object or null" + proto);
              }
            };
            var setPrototypeOf = function(O, proto) {
              checkArgs(O, proto);
              set.call(O, proto);
              return O;
            };
            try {
              set = Object2.getOwnPropertyDescriptor(Object2.prototype, magic).set;
              set.call({}, null);
            } catch (e) {
              if (Object2.prototype !== {}[magic]) {
                return;
              }
              set = function(proto) {
                this[magic] = proto;
              };
              setPrototypeOf.polyfill = setPrototypeOf(
                setPrototypeOf({}, null),
                Object2.prototype
              ) instanceof Object2;
            }
            return setPrototypeOf;
          }(Object, "__proto__")
        });
      }
      if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(/* @__PURE__ */ Object.create(null)) === null) {
        (function() {
          var FAKENULL = /* @__PURE__ */ Object.create(null);
          var gpo = Object.getPrototypeOf, spo = Object.setPrototypeOf;
          Object.getPrototypeOf = function(o) {
            var result = gpo(o);
            return result === FAKENULL ? null : result;
          };
          Object.setPrototypeOf = function(o, p) {
            if (p === null) {
              p = FAKENULL;
            }
            return spo(o, p);
          };
          Object.setPrototypeOf.polyfill = false;
        })();
      }
      try {
        Object.keys("foo");
      } catch (e) {
        var originalObjectKeys = Object.keys;
        Object.keys = function(obj2) {
          return originalObjectKeys(ES.ToObject(obj2));
        };
      }
      if (!RegExp.prototype.flags && supportsDescriptors) {
        var regExpFlagsGetter = function flags() {
          if (!ES.TypeIsObject(this)) {
            throw new TypeError("Method called on incompatible type: must be an object.");
          }
          var result = "";
          if (this.global) {
            result += "g";
          }
          if (this.ignoreCase) {
            result += "i";
          }
          if (this.multiline) {
            result += "m";
          }
          if (this.unicode) {
            result += "u";
          }
          if (this.sticky) {
            result += "y";
          }
          return result;
        };
        Value.getter(RegExp.prototype, "flags", regExpFlagsGetter);
      }
      var regExpSupportsFlagsWithRegex = function() {
        try {
          return String(new RegExp(/a/g, "i")) === "/a/i";
        } catch (e) {
          return false;
        }
      }();
      if (!regExpSupportsFlagsWithRegex && supportsDescriptors) {
        var OrigRegExp = RegExp;
        var RegExpShim = function RegExp2(pattern, flags) {
          if (Type.regex(pattern) && Type.string(flags)) {
            return new RegExp2(pattern.source, flags);
          }
          return new OrigRegExp(pattern, flags);
        };
        defineProperty(RegExpShim, "toString", OrigRegExp.toString.bind(OrigRegExp), true);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(OrigRegExp, RegExpShim);
        }
        Object.getOwnPropertyNames(OrigRegExp).forEach(function(key) {
          if (key === "$input") {
            return;
          }
          if (key in noop) {
            return;
          }
          Value.proxy(OrigRegExp, key, RegExpShim);
        });
        RegExpShim.prototype = OrigRegExp.prototype;
        Value.redefine(OrigRegExp.prototype, "constructor", RegExpShim);
        RegExp = RegExpShim;
        Value.redefine(globals, "RegExp", RegExpShim);
      }
      var MathShims = {
        acosh: function(value) {
          value = Number(value);
          if (Number.isNaN(value) || value < 1) {
            return NaN;
          }
          if (value === 1) {
            return 0;
          }
          if (value === Infinity) {
            return value;
          }
          return Math.log(value + Math.sqrt(value * value - 1));
        },
        asinh: function(value) {
          value = Number(value);
          if (value === 0 || !global_isFinite(value)) {
            return value;
          }
          return value < 0 ? -Math.asinh(-value) : Math.log(value + Math.sqrt(value * value + 1));
        },
        atanh: function(value) {
          value = Number(value);
          if (Number.isNaN(value) || value < -1 || value > 1) {
            return NaN;
          }
          if (value === -1) {
            return -Infinity;
          }
          if (value === 1) {
            return Infinity;
          }
          if (value === 0) {
            return value;
          }
          return 0.5 * Math.log((1 + value) / (1 - value));
        },
        cbrt: function(value) {
          value = Number(value);
          if (value === 0) {
            return value;
          }
          var negate = value < 0, result;
          if (negate) {
            value = -value;
          }
          result = Math.pow(value, 1 / 3);
          return negate ? -result : result;
        },
        clz32: function(value) {
          value = Number(value);
          var number = ES.ToUint32(value);
          if (number === 0) {
            return 32;
          }
          return 32 - number.toString(2).length;
        },
        cosh: function(value) {
          value = Number(value);
          if (value === 0) {
            return 1;
          }
          if (Number.isNaN(value)) {
            return NaN;
          }
          if (!global_isFinite(value)) {
            return Infinity;
          }
          if (value < 0) {
            value = -value;
          }
          if (value > 21) {
            return Math.exp(value) / 2;
          }
          return (Math.exp(value) + Math.exp(-value)) / 2;
        },
        expm1: function(value) {
          value = Number(value);
          if (value === -Infinity) {
            return -1;
          }
          if (!global_isFinite(value) || value === 0) {
            return value;
          }
          return Math.exp(value) - 1;
        },
        hypot: function(x, y) {
          var anyNaN = false;
          var allZero = true;
          var anyInfinity = false;
          var numbers = [];
          Array.prototype.every.call(arguments, function(arg) {
            var num = Number(arg);
            if (Number.isNaN(num)) {
              anyNaN = true;
            } else if (num === Infinity || num === -Infinity) {
              anyInfinity = true;
            } else if (num !== 0) {
              allZero = false;
            }
            if (anyInfinity) {
              return false;
            } else if (!anyNaN) {
              numbers.push(Math.abs(num));
            }
            return true;
          });
          if (anyInfinity) {
            return Infinity;
          }
          if (anyNaN) {
            return NaN;
          }
          if (allZero) {
            return 0;
          }
          numbers.sort(function(a, b) {
            return b - a;
          });
          var largest = numbers[0];
          var divided = numbers.map(function(number) {
            return number / largest;
          });
          var sum = divided.reduce(function(sum2, number) {
            return sum2 + number * number;
          }, 0);
          return largest * Math.sqrt(sum);
        },
        log2: function(value) {
          return Math.log(value) * Math.LOG2E;
        },
        log10: function(value) {
          return Math.log(value) * Math.LOG10E;
        },
        log1p: function(value) {
          value = Number(value);
          if (value < -1 || Number.isNaN(value)) {
            return NaN;
          }
          if (value === 0 || value === Infinity) {
            return value;
          }
          if (value === -1) {
            return -Infinity;
          }
          var result = 0;
          var n = 50;
          if (value < 0 || value > 1) {
            return Math.log(1 + value);
          }
          for (var i = 1; i < n; i++) {
            if (i % 2 === 0) {
              result -= Math.pow(value, i) / i;
            } else {
              result += Math.pow(value, i) / i;
            }
          }
          return result;
        },
        sign: function(value) {
          var number = +value;
          if (number === 0) {
            return number;
          }
          if (Number.isNaN(number)) {
            return number;
          }
          return number < 0 ? -1 : 1;
        },
        sinh: function(value) {
          value = Number(value);
          if (!global_isFinite(value) || value === 0) {
            return value;
          }
          return (Math.exp(value) - Math.exp(-value)) / 2;
        },
        tanh: function(value) {
          value = Number(value);
          if (Number.isNaN(value) || value === 0) {
            return value;
          }
          if (value === Infinity) {
            return 1;
          }
          if (value === -Infinity) {
            return -1;
          }
          return (Math.exp(value) - Math.exp(-value)) / (Math.exp(value) + Math.exp(-value));
        },
        trunc: function(value) {
          var number = Number(value);
          return number < 0 ? -Math.floor(-number) : Math.floor(number);
        },
        imul: function(x, y) {
          x = ES.ToUint32(x);
          y = ES.ToUint32(y);
          var ah = x >>> 16 & 65535;
          var al = x & 65535;
          var bh = y >>> 16 & 65535;
          var bl = y & 65535;
          return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
        },
        fround: function(x) {
          if (x === 0 || x === Infinity || x === -Infinity || Number.isNaN(x)) {
            return x;
          }
          var num = Number(x);
          return numberConversion.toFloat32(num);
        }
      };
      defineProperties(Math, MathShims);
      if (Math.imul(4294967295, 5) !== -5) {
        Math.imul = MathShims.imul;
      }
      var PromiseShim = function() {
        var Promise2, Promise$prototype;
        ES.IsPromise = function(promise) {
          if (!ES.TypeIsObject(promise)) {
            return false;
          }
          if (!promise._promiseConstructor) {
            return false;
          }
          if (typeof promise._status === "undefined") {
            return false;
          }
          return true;
        };
        var PromiseCapability = function(C) {
          if (!ES.IsCallable(C)) {
            throw new TypeError("bad promise constructor");
          }
          var capability = this;
          var resolver = function(resolve, reject) {
            capability.resolve = resolve;
            capability.reject = reject;
          };
          capability.promise = ES.Construct(C, [resolver]);
          if (!capability.promise._es6construct) {
            throw new TypeError("bad promise constructor");
          }
          if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
            throw new TypeError("bad promise constructor");
          }
        };
        var setTimeout2 = globals.setTimeout;
        var makeZeroTimeout;
        if (typeof window !== "undefined" && ES.IsCallable(window.postMessage)) {
          makeZeroTimeout = function() {
            var timeouts = [];
            var messageName = "zero-timeout-message";
            var setZeroTimeout = function(fn) {
              timeouts.push(fn);
              window.postMessage(messageName, "*");
            };
            var handleMessage = function(event) {
              if (event.source === window && event.data === messageName) {
                event.stopPropagation();
                if (timeouts.length === 0) {
                  return;
                }
                var fn = timeouts.shift();
                fn();
              }
            };
            window.addEventListener("message", handleMessage, true);
            return setZeroTimeout;
          };
        }
        var makePromiseAsap = function() {
          var P = globals.Promise;
          return P && P.resolve && function(task) {
            return P.resolve().then(task);
          };
        };
        var enqueue = ES.IsCallable(globals.setImmediate) ? globals.setImmediate.bind(globals) : typeof process === "object" && process.nextTick ? process.nextTick : makePromiseAsap() || (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function(task) {
          setTimeout2(task, 0);
        });
        var updatePromiseFromPotentialThenable = function(x, capability) {
          if (!ES.TypeIsObject(x)) {
            return false;
          }
          var resolve = capability.resolve;
          var reject = capability.reject;
          try {
            var then = x.then;
            if (!ES.IsCallable(then)) {
              return false;
            }
            then.call(x, resolve, reject);
          } catch (e) {
            reject(e);
          }
          return true;
        };
        var triggerPromiseReactions = function(reactions, x) {
          reactions.forEach(function(reaction) {
            enqueue(function() {
              var handler = reaction.handler;
              var capability = reaction.capability;
              var resolve = capability.resolve;
              var reject = capability.reject;
              try {
                var result = handler(x);
                if (result === capability.promise) {
                  throw new TypeError("self resolution");
                }
                var updateResult = updatePromiseFromPotentialThenable(result, capability);
                if (!updateResult) {
                  resolve(result);
                }
              } catch (e) {
                reject(e);
              }
            });
          });
        };
        var promiseResolutionHandler = function(promise, onFulfilled, onRejected) {
          return function(x) {
            if (x === promise) {
              return onRejected(new TypeError("self resolution"));
            }
            var C = promise._promiseConstructor;
            var capability = new PromiseCapability(C);
            var updateResult = updatePromiseFromPotentialThenable(x, capability);
            if (updateResult) {
              return capability.promise.then(onFulfilled, onRejected);
            } else {
              return onFulfilled(x);
            }
          };
        };
        Promise2 = function(resolver) {
          var promise = this;
          promise = emulateES6construct(promise);
          if (!promise._promiseConstructor) {
            throw new TypeError("bad promise");
          }
          if (typeof promise._status !== "undefined") {
            throw new TypeError("promise already initialized");
          }
          if (!ES.IsCallable(resolver)) {
            throw new TypeError("not a valid resolver");
          }
          promise._status = "unresolved";
          promise._resolveReactions = [];
          promise._rejectReactions = [];
          var resolve = function(resolution) {
            if (promise._status !== "unresolved") {
              return;
            }
            var reactions = promise._resolveReactions;
            promise._result = resolution;
            promise._resolveReactions = void 0;
            promise._rejectReactions = void 0;
            promise._status = "has-resolution";
            triggerPromiseReactions(reactions, resolution);
          };
          var reject = function(reason) {
            if (promise._status !== "unresolved") {
              return;
            }
            var reactions = promise._rejectReactions;
            promise._result = reason;
            promise._resolveReactions = void 0;
            promise._rejectReactions = void 0;
            promise._status = "has-rejection";
            triggerPromiseReactions(reactions, reason);
          };
          try {
            resolver(resolve, reject);
          } catch (e) {
            reject(e);
          }
          return promise;
        };
        Promise$prototype = Promise2.prototype;
        var _promiseAllResolver = function(index, values, capability, remaining) {
          var done = false;
          return function(x) {
            if (done) {
              return;
            }
            done = true;
            values[index] = x;
            if (--remaining.count === 0) {
              var resolve = capability.resolve;
              resolve(values);
            }
          };
        };
        defineProperties(Promise2, {
          "@@create": function(obj2) {
            var constructor = this;
            var prototype = constructor.prototype || Promise$prototype;
            obj2 = obj2 || create(prototype);
            defineProperties(obj2, {
              _status: void 0,
              _result: void 0,
              _resolveReactions: void 0,
              _rejectReactions: void 0,
              _promiseConstructor: void 0
            });
            obj2._promiseConstructor = constructor;
            return obj2;
          },
          all: function all(iterable) {
            var C = this;
            var capability = new PromiseCapability(C);
            var resolve = capability.resolve;
            var reject = capability.reject;
            try {
              if (!ES.IsIterable(iterable)) {
                throw new TypeError("bad iterable");
              }
              var it = ES.GetIterator(iterable);
              var values = [], remaining = { count: 1 };
              for (var index = 0; ; index++) {
                var next = ES.IteratorNext(it);
                if (next.done) {
                  break;
                }
                var nextPromise = C.resolve(next.value);
                var resolveElement = _promiseAllResolver(
                  index,
                  values,
                  capability,
                  remaining
                );
                remaining.count++;
                nextPromise.then(resolveElement, capability.reject);
              }
              if (--remaining.count === 0) {
                resolve(values);
              }
            } catch (e) {
              reject(e);
            }
            return capability.promise;
          },
          race: function race(iterable) {
            var C = this;
            var capability = new PromiseCapability(C);
            var resolve = capability.resolve;
            var reject = capability.reject;
            try {
              if (!ES.IsIterable(iterable)) {
                throw new TypeError("bad iterable");
              }
              var it = ES.GetIterator(iterable);
              while (true) {
                var next = ES.IteratorNext(it);
                if (next.done) {
                  break;
                }
                var nextPromise = C.resolve(next.value);
                nextPromise.then(resolve, reject);
              }
            } catch (e) {
              reject(e);
            }
            return capability.promise;
          },
          reject: function reject(reason) {
            var C = this;
            var capability = new PromiseCapability(C);
            var rejectPromise = capability.reject;
            rejectPromise(reason);
            return capability.promise;
          },
          resolve: function resolve(v) {
            var C = this;
            if (ES.IsPromise(v)) {
              var constructor = v._promiseConstructor;
              if (constructor === C) {
                return v;
              }
            }
            var capability = new PromiseCapability(C);
            var resolvePromise = capability.resolve;
            resolvePromise(v);
            return capability.promise;
          }
        });
        defineProperties(Promise$prototype, {
          "catch": function(onRejected) {
            return this.then(void 0, onRejected);
          },
          then: function then(onFulfilled, onRejected) {
            var promise = this;
            if (!ES.IsPromise(promise)) {
              throw new TypeError("not a promise");
            }
            var C = this.constructor;
            var capability = new PromiseCapability(C);
            if (!ES.IsCallable(onRejected)) {
              onRejected = function(e) {
                throw e;
              };
            }
            if (!ES.IsCallable(onFulfilled)) {
              onFulfilled = function(x) {
                return x;
              };
            }
            var resolutionHandler = promiseResolutionHandler(promise, onFulfilled, onRejected);
            var resolveReaction = { capability, handler: resolutionHandler };
            var rejectReaction = { capability, handler: onRejected };
            switch (promise._status) {
              case "unresolved":
                promise._resolveReactions.push(resolveReaction);
                promise._rejectReactions.push(rejectReaction);
                break;
              case "has-resolution":
                triggerPromiseReactions([resolveReaction], promise._result);
                break;
              case "has-rejection":
                triggerPromiseReactions([rejectReaction], promise._result);
                break;
              default:
                throw new TypeError("unexpected");
            }
            return capability.promise;
          }
        });
        return Promise2;
      }();
      if (globals.Promise) {
        delete globals.Promise.accept;
        delete globals.Promise.defer;
        delete globals.Promise.prototype.chain;
      }
      defineProperties(globals, { Promise: PromiseShim });
      var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function(S) {
        return S.resolve(42) instanceof S;
      });
      var promiseIgnoresNonFunctionThenCallbacks = function() {
        try {
          globals.Promise.reject(42).then(null, 5).then(null, noop);
          return true;
        } catch (ex) {
          return false;
        }
      }();
      var promiseRequiresObjectContext = function() {
        try {
          Promise.call(3, noop);
        } catch (e) {
          return true;
        }
        return false;
      }();
      if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks || !promiseRequiresObjectContext) {
        Promise = PromiseShim;
        defineProperty(globals, "Promise", PromiseShim, true);
      }
      var testOrder = function(a) {
        var b = Object.keys(a.reduce(function(o, k) {
          o[k] = true;
          return o;
        }, {}));
        return a.join(":") === b.join(":");
      };
      var preservesInsertionOrder = testOrder(["z", "a", "bb"]);
      var preservesNumericInsertionOrder = testOrder(["z", 1, "a", "3", 2]);
      if (supportsDescriptors) {
        var fastkey = function fastkey2(key) {
          if (!preservesInsertionOrder) {
            return null;
          }
          var type = typeof key;
          if (type === "string") {
            return "$" + key;
          } else if (type === "number") {
            if (!preservesNumericInsertionOrder) {
              return "n" + key;
            }
            return key;
          }
          return null;
        };
        var emptyObject = function emptyObject2() {
          return Object.create ? /* @__PURE__ */ Object.create(null) : {};
        };
        var collectionShims = {
          Map: function() {
            var empty = {};
            function MapEntry(key, value) {
              this.key = key;
              this.value = value;
              this.next = null;
              this.prev = null;
            }
            MapEntry.prototype.isRemoved = function() {
              return this.key === empty;
            };
            function MapIterator(map, kind) {
              this.head = map._head;
              this.i = this.head;
              this.kind = kind;
            }
            MapIterator.prototype = {
              next: function() {
                var i = this.i, kind = this.kind, head = this.head, result;
                if (typeof this.i === "undefined") {
                  return { value: void 0, done: true };
                }
                while (i.isRemoved() && i !== head) {
                  i = i.prev;
                }
                while (i.next !== head) {
                  i = i.next;
                  if (!i.isRemoved()) {
                    if (kind === "key") {
                      result = i.key;
                    } else if (kind === "value") {
                      result = i.value;
                    } else {
                      result = [i.key, i.value];
                    }
                    this.i = i;
                    return { value: result, done: false };
                  }
                }
                this.i = void 0;
                return { value: void 0, done: true };
              }
            };
            addIterator(MapIterator.prototype);
            function Map(iterable) {
              var map = this;
              if (!ES.TypeIsObject(map)) {
                throw new TypeError("Map does not accept arguments when called as a function");
              }
              map = emulateES6construct(map);
              if (!map._es6map) {
                throw new TypeError("bad map");
              }
              var head = new MapEntry(null, null);
              head.next = head.prev = head;
              defineProperties(map, {
                _head: head,
                _storage: emptyObject(),
                _size: 0
              });
              if (typeof iterable !== "undefined" && iterable !== null) {
                var it = ES.GetIterator(iterable);
                var adder = map.set;
                if (!ES.IsCallable(adder)) {
                  throw new TypeError("bad map");
                }
                while (true) {
                  var next = ES.IteratorNext(it);
                  if (next.done) {
                    break;
                  }
                  var nextItem = next.value;
                  if (!ES.TypeIsObject(nextItem)) {
                    throw new TypeError("expected iterable of pairs");
                  }
                  adder.call(map, nextItem[0], nextItem[1]);
                }
              }
              return map;
            }
            var Map$prototype = Map.prototype;
            defineProperties(Map, {
              "@@create": function(obj2) {
                var constructor = this;
                var prototype = constructor.prototype || Map$prototype;
                obj2 = obj2 || create(prototype);
                defineProperties(obj2, { _es6map: true });
                return obj2;
              }
            });
            Value.getter(Map.prototype, "size", function() {
              if (typeof this._size === "undefined") {
                throw new TypeError("size method called on incompatible Map");
              }
              return this._size;
            });
            defineProperties(Map.prototype, {
              get: function(key) {
                var fkey = fastkey(key);
                if (fkey !== null) {
                  var entry = this._storage[fkey];
                  if (entry) {
                    return entry.value;
                  } else {
                    return;
                  }
                }
                var head = this._head, i = head;
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    return i.value;
                  }
                }
              },
              has: function(key) {
                var fkey = fastkey(key);
                if (fkey !== null) {
                  return typeof this._storage[fkey] !== "undefined";
                }
                var head = this._head, i = head;
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    return true;
                  }
                }
                return false;
              },
              set: function(key, value) {
                var head = this._head, i = head, entry;
                var fkey = fastkey(key);
                if (fkey !== null) {
                  if (typeof this._storage[fkey] !== "undefined") {
                    this._storage[fkey].value = value;
                    return this;
                  } else {
                    entry = this._storage[fkey] = new MapEntry(key, value);
                    i = head.prev;
                  }
                }
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    i.value = value;
                    return this;
                  }
                }
                entry = entry || new MapEntry(key, value);
                if (ES.SameValue(-0, key)) {
                  entry.key = 0;
                }
                entry.next = this._head;
                entry.prev = this._head.prev;
                entry.prev.next = entry;
                entry.next.prev = entry;
                this._size += 1;
                return this;
              },
              "delete": function(key) {
                var head = this._head, i = head;
                var fkey = fastkey(key);
                if (fkey !== null) {
                  if (typeof this._storage[fkey] === "undefined") {
                    return false;
                  }
                  i = this._storage[fkey].prev;
                  delete this._storage[fkey];
                }
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    i.key = i.value = empty;
                    i.prev.next = i.next;
                    i.next.prev = i.prev;
                    this._size -= 1;
                    return true;
                  }
                }
                return false;
              },
              clear: function() {
                this._size = 0;
                this._storage = emptyObject();
                var head = this._head, i = head, p = i.next;
                while ((i = p) !== head) {
                  i.key = i.value = empty;
                  p = i.next;
                  i.next = i.prev = head;
                }
                head.next = head.prev = head;
              },
              keys: function() {
                return new MapIterator(this, "key");
              },
              values: function() {
                return new MapIterator(this, "value");
              },
              entries: function() {
                return new MapIterator(this, "key+value");
              },
              forEach: function(callback) {
                var context = arguments.length > 1 ? arguments[1] : null;
                var it = this.entries();
                for (var entry = it.next(); !entry.done; entry = it.next()) {
                  if (context) {
                    callback.call(context, entry.value[1], entry.value[0], this);
                  } else {
                    callback(entry.value[1], entry.value[0], this);
                  }
                }
              }
            });
            addIterator(Map.prototype, function() {
              return this.entries();
            });
            return Map;
          }(),
          Set: function() {
            var SetShim = function Set(iterable) {
              var set = this;
              if (!ES.TypeIsObject(set)) {
                throw new TypeError("Set does not accept arguments when called as a function");
              }
              set = emulateES6construct(set);
              if (!set._es6set) {
                throw new TypeError("bad set");
              }
              defineProperties(set, {
                "[[SetData]]": null,
                _storage: emptyObject()
              });
              if (typeof iterable !== "undefined" && iterable !== null) {
                var it = ES.GetIterator(iterable);
                var adder = set.add;
                if (!ES.IsCallable(adder)) {
                  throw new TypeError("bad set");
                }
                while (true) {
                  var next = ES.IteratorNext(it);
                  if (next.done) {
                    break;
                  }
                  var nextItem = next.value;
                  adder.call(set, nextItem);
                }
              }
              return set;
            };
            var Set$prototype = SetShim.prototype;
            defineProperties(SetShim, {
              "@@create": function(obj2) {
                var constructor = this;
                var prototype = constructor.prototype || Set$prototype;
                obj2 = obj2 || create(prototype);
                defineProperties(obj2, { _es6set: true });
                return obj2;
              }
            });
            var ensureMap = function ensureMap2(set) {
              if (!set["[[SetData]]"]) {
                var m = set["[[SetData]]"] = new collectionShims.Map();
                Object.keys(set._storage).forEach(function(k) {
                  if (k.charCodeAt(0) === 36) {
                    k = k.slice(1);
                  } else if (k.charAt(0) === "n") {
                    k = +k.slice(1);
                  } else {
                    k = +k;
                  }
                  m.set(k, k);
                });
                set._storage = null;
              }
            };
            Value.getter(SetShim.prototype, "size", function() {
              if (typeof this._storage === "undefined") {
                throw new TypeError("size method called on incompatible Set");
              }
              ensureMap(this);
              return this["[[SetData]]"].size;
            });
            defineProperties(SetShim.prototype, {
              has: function(key) {
                var fkey;
                if (this._storage && (fkey = fastkey(key)) !== null) {
                  return !!this._storage[fkey];
                }
                ensureMap(this);
                return this["[[SetData]]"].has(key);
              },
              add: function(key) {
                var fkey;
                if (this._storage && (fkey = fastkey(key)) !== null) {
                  this._storage[fkey] = true;
                  return this;
                }
                ensureMap(this);
                this["[[SetData]]"].set(key, key);
                return this;
              },
              "delete": function(key) {
                var fkey;
                if (this._storage && (fkey = fastkey(key)) !== null) {
                  var hasFKey = _hasOwnProperty(this._storage, fkey);
                  return delete this._storage[fkey] && hasFKey;
                }
                ensureMap(this);
                return this["[[SetData]]"]["delete"](key);
              },
              clear: function() {
                if (this._storage) {
                  this._storage = emptyObject();
                } else {
                  this["[[SetData]]"].clear();
                }
              },
              values: function() {
                ensureMap(this);
                return this["[[SetData]]"].values();
              },
              entries: function() {
                ensureMap(this);
                return this["[[SetData]]"].entries();
              },
              forEach: function(callback) {
                var context = arguments.length > 1 ? arguments[1] : null;
                var entireSet = this;
                ensureMap(entireSet);
                this["[[SetData]]"].forEach(function(value, key) {
                  if (context) {
                    callback.call(context, key, key, entireSet);
                  } else {
                    callback(key, key, entireSet);
                  }
                });
              }
            });
            defineProperty(SetShim, "keys", SetShim.values, true);
            addIterator(SetShim.prototype, function() {
              return this.values();
            });
            return SetShim;
          }()
        };
        defineProperties(globals, collectionShims);
        if (globals.Map || globals.Set) {
          if (typeof globals.Map.prototype.clear !== "function" || new globals.Set().size !== 0 || new globals.Map().size !== 0 || typeof globals.Map.prototype.keys !== "function" || typeof globals.Set.prototype.keys !== "function" || typeof globals.Map.prototype.forEach !== "function" || typeof globals.Set.prototype.forEach !== "function" || isCallableWithoutNew(globals.Map) || isCallableWithoutNew(globals.Set) || !supportsSubclassing(globals.Map, function(M) {
            var m = new M([]);
            m.set(42, 42);
            return m instanceof M;
          })) {
            globals.Map = collectionShims.Map;
            globals.Set = collectionShims.Set;
          }
        }
        if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
          defineProperty(globals.Set.prototype, "keys", globals.Set.prototype.values, true);
        }
        addIterator(Object.getPrototypeOf(new globals.Map().keys()));
        addIterator(Object.getPrototypeOf(new globals.Set().keys()));
      }
      return globals;
    });
  }
});

// node_modules/node-wordnet/lib/wordnet.js
var require_wordnet = __commonJS({
  "node_modules/node-wordnet/lib/wordnet.js"(exports2, module2) {
    var DataFile;
    var IndexFile;
    var LRU;
    var Promise2;
    var WordNet;
    var async;
    var fs;
    var path;
    var slice = [].slice;
    IndexFile = require_index_file();
    DataFile = require_data_file();
    async = require_async();
    Promise2 = require_bluebird();
    path = require_path();
    fs = require_fs();
    LRU = require_lru_cache();
    require_es6_shim();
    WordNet = function() {
      var _forms, _loadExceptions, _validForms, _validFormsWithExceptions, exceptions, forms, tokenDetach, unique;
      function WordNet2(options) {
        var WNdb, e, error;
        if (typeof options === "string") {
          options = {
            dataDir: options
          };
        } else {
          if (options == null) {
            options = {};
          }
        }
        if (options.dataDir == null) {
          try {
            WNdb = __require("wndb-with-exceptions");
          } catch (error2) {
            e = error2;
            console.error("Please 'npm install wndb-with-exceptions' before using WordNet module or specify a dict directory.");
            throw e;
          }
          options.dataDir = WNdb.path;
        }
        if (!options.cache) {
          this.cache = null;
        } else {
          if (options.cache === true) {
            options.cache = {
              max: 2e3
            };
          }
          if (typeof options.cache === "object" && typeof options.cache.get === "function") {
            this.cache = options.cache;
          } else {
            this.cache = LRU(options.cache);
          }
        }
        this.path = options.dataDir;
        this.nounIndex = new IndexFile(this.path, "noun");
        this.verbIndex = new IndexFile(this.path, "verb");
        this.adjIndex = new IndexFile(this.path, "adj");
        this.advIndex = new IndexFile(this.path, "adv");
        this.nounData = new DataFile(this.path, "noun");
        this.verbData = new DataFile(this.path, "verb");
        this.adjData = new DataFile(this.path, "adj");
        this.advData = new DataFile(this.path, "adv");
        this.allFiles = [
          {
            index: this.nounIndex,
            data: this.nounData,
            pos: "n"
          },
          {
            index: this.verbIndex,
            data: this.verbData,
            pos: "v"
          },
          {
            index: this.adjIndex,
            data: this.adjData,
            pos: "a"
          },
          {
            index: this.advIndex,
            data: this.advData,
            pos: "r"
          }
        ];
      }
      WordNet2.prototype.get = function(synsetOffset, pos, callback) {
        var dataFile, hit, query, wordnet;
        wordnet = this;
        if (this.cache) {
          query = "get:" + synsetOffset + ":" + pos;
          if (hit = wordnet.cache.get(query)) {
            if (callback.length === 1) {
              return callback.call(wordnet, hit);
            } else {
              return callback.call(wordnet, null, hit);
            }
          }
        }
        dataFile = wordnet.getDataFile(pos);
        return dataFile.get(synsetOffset, function(err, result) {
          if (query && err == null) {
            wordnet.cache.set(query, result);
          }
          if (callback.length === 1) {
            return callback.call(wordnet, result);
          } else {
            return callback.call(wordnet, err, result);
          }
        });
      };
      WordNet2.prototype.getAsync = function(synsetOffset, pos) {
        var wordnet;
        wordnet = this;
        return new Promise2(function(resolve, reject) {
          return wordnet.get(synsetOffset, pos, function(err, data) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      };
      WordNet2.prototype.lookup = function(input, callback) {
        var hit, lword, pos, query, ref, selectedFiles, word, wordnet;
        wordnet = this;
        ref = input.split("#"), word = ref[0], pos = ref[1];
        lword = word.toLowerCase().replace(/\s+/g, "_");
        if (this.cache) {
          query = "lookup:" + input;
          if (hit = wordnet.cache.get(query)) {
            if (callback.length === 1) {
              return callback.call(wordnet, hit);
            } else {
              return callback.call(wordnet, null, hit);
            }
          }
        }
        selectedFiles = !pos ? wordnet.allFiles.slice() : wordnet.allFiles.filter(function(file) {
          return file.pos === pos;
        });
        return wordnet.lookupFromFiles(selectedFiles, [], lword, function(err, results) {
          if (err != null) {
            return callback.call(wordnet, err);
          }
          if (query) {
            wordnet.cache.set(query, results);
          }
          if (callback.length === 1) {
            return callback.call(wordnet, results);
          } else {
            return callback.call(wordnet, null, results);
          }
        });
      };
      WordNet2.prototype.lookupAsync = function(input, callback) {
        var wordnet;
        wordnet = this;
        return new Promise2(function(resolve, reject) {
          return wordnet.lookup(input, function(err, data) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      };
      WordNet2.prototype.findSense = function(input, callback) {
        var hit, lword, pos, query, ref, selectedFiles, sense, senseNumber, word, wordnet;
        wordnet = this;
        ref = input.split("#"), word = ref[0], pos = ref[1], senseNumber = ref[2];
        if (this.cache) {
          query = "findSense:" + input;
          if (hit = wordnet.cache.get(query)) {
            if (callback.length === 1) {
              return callback.call(wordnet, hit);
            } else {
              return callback.call(wordnet, null, hit);
            }
          }
        }
        sense = parseInt(senseNumber);
        if (Number.isNaN(sense)) {
          throw new Error("Sense number should be an integer");
        } else if (sense < 1) {
          throw new Error("Sense number should be a positive integer");
        }
        lword = word.toLowerCase().replace(/\s+/g, "_");
        selectedFiles = wordnet.allFiles.filter(function(file) {
          return file.pos === pos;
        });
        return wordnet.lookupFromFiles(selectedFiles, [], lword, function(err, response) {
          var result;
          if (err != null) {
            return callback.call(wordnet, err);
          }
          result = response[sense - 1];
          if (query) {
            wordnet.cache.set(query, result);
          }
          if (callback.length === 1) {
            return callback.call(wordnet, result);
          } else {
            return callback.call(wordnet, null, result);
          }
        });
      };
      WordNet2.prototype.findSenseAsync = function(input) {
        var wordnet;
        wordnet = this;
        return new Promise2(function(resolve, reject) {
          return wordnet.findSense(input, function(err, data) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      };
      WordNet2.prototype.querySense = function(input, callback) {
        var hit, pos, query, ref, word, wordnet;
        wordnet = this;
        ref = input.split("#"), word = ref[0], pos = ref[1];
        if (this.cache) {
          query = "querySense:" + input;
          if (hit = wordnet.cache.get(query)) {
            if (callback.length === 1) {
              return callback.call(wordnet, hit);
            } else {
              return callback.call(wordnet, null, hit);
            }
          }
        }
        return wordnet.lookup(input, function(err, results) {
          var i, sense, senseCounts, senses;
          if (err != null) {
            return callback.call(wordnet, err);
          }
          senseCounts = {};
          senses = function() {
            var j, len, results1;
            results1 = [];
            for (i = j = 0, len = results.length; j < len; i = ++j) {
              sense = results[i];
              pos = sense.pos;
              if (pos === "s") {
                pos = "a";
              }
              if (senseCounts[pos] == null) {
                senseCounts[pos] = 1;
              }
              results1.push(word + "#" + pos + "#" + senseCounts[pos]++);
            }
            return results1;
          }();
          if (query) {
            wordnet.cache.set(query, senses);
          }
          if (callback.length === 1) {
            return callback.call(wordnet, senses);
          } else {
            return callback.call(wordnet, null, senses);
          }
        });
      };
      WordNet2.prototype.querySenseAsync = function(input) {
        var wordnet;
        wordnet = this;
        return new Promise2(function(resolve, reject) {
          return wordnet.querySense(input, function(err, data) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      };
      WordNet2.prototype.lookupFromFiles = function(files, results, word, callback) {
        var file, wordnet;
        wordnet = this;
        if (files.length === 0) {
          return callback.call(wordnet, null, results);
        } else {
          file = files.pop();
          return file.index.lookup(word, function(err, record) {
            if (record) {
              return wordnet.pushResults(file.data, results, record.synsetOffset, function() {
                return wordnet.lookupFromFiles(files, results, word, callback);
              });
            } else {
              return wordnet.lookupFromFiles(files, results, word, callback);
            }
          });
        }
      };
      WordNet2.prototype.pushResults = function(data, results, offsets, callback) {
        var wordnet;
        wordnet = this;
        if (offsets.length === 0) {
          return callback(results);
        } else {
          return data.get(offsets.pop(), function(err, record) {
            results.push(record);
            return wordnet.pushResults(data, results, offsets, callback);
          });
        }
      };
      WordNet2.prototype.loadResultSynonyms = function(synonyms, results, callback) {
        var result, wordnet;
        wordnet = this;
        if (results.length > 0) {
          result = results.pop();
          return wordnet.loadSynonyms(synonyms, results, result.ptrs, callback);
        } else {
          return callback(synonyms);
        }
      };
      WordNet2.prototype.loadSynonyms = function(synonyms, results, ptrs, callback) {
        var ptr, wordnet;
        wordnet = this;
        if (ptrs.length > 0) {
          ptr = ptrs.pop();
          return this.get(ptr.synsetOffset, ptr.pos, function(result) {
            synonyms.push(result);
            return wordnet.loadSynonyms(synonyms, results, ptrs, callback);
          });
        } else {
          return wordnet.loadResultSynonyms(synonyms, results, callback);
        }
      };
      WordNet2.prototype.lookupSynonyms = function(word, callback) {
        var wordnet;
        wordnet = this;
        return wordnet.lookup(word, function(results) {
          return wordnet.loadResultSynonyms([], results, callback);
        });
      };
      WordNet2.prototype.getSynonyms = function() {
        var callback, pos, synsetOffset, wordnet;
        wordnet = this;
        callback = arguments[2] ? arguments[2] : arguments[1];
        pos = arguments[0].pos ? arguments[0].pos : arguments[1];
        synsetOffset = arguments[0].synsetOffset ? arguments[0].synsetOffset : arguments[0];
        return this.get(synsetOffset, pos, function(result) {
          return wordnet.loadSynonyms([], [], result.ptrs, callback);
        });
      };
      WordNet2.prototype.getDataFile = function(pos) {
        switch (pos) {
          case "n":
            return this.nounData;
          case "v":
            return this.verbData;
          case "a":
          case "s":
            return this.adjData;
          case "r":
            return this.advData;
        }
      };
      exceptions = [
        {
          name: "noun.exc",
          pos: "n"
        },
        {
          name: "verb.exc",
          pos: "v"
        },
        {
          name: "adj.exc",
          pos: "a"
        },
        {
          name: "adv.exc",
          pos: "r"
        }
      ];
      _loadExceptions = function(wordnet, callback) {
        var loadFile;
        WordNet2.prototype.exceptions = "pending";
        loadFile = function(exception, callback2) {
          var fullPath;
          fullPath = path.join(wordnet.path, exception.name);
          return fs.readFile(fullPath, function(err, data) {
            var j, len, line, lines, ref, temp, term1, term2;
            if (err) {
              return callback2(err);
            }
            temp = {};
            lines = data.toString().split("\n");
            for (j = 0, len = lines.length; j < len; j++) {
              line = lines[j];
              if (line.length > 0) {
                ref = line.split(" "), term1 = ref[0], term2 = 2 <= ref.length ? slice.call(ref, 1) : [];
                if (temp[term1] == null) {
                  temp[term1] = [];
                }
                Array.prototype.push.apply(temp[term1], term2);
              }
            }
            return callback2(null, {
              pos: exception.pos,
              data: temp
            });
          });
        };
        return async.map(exceptions, loadFile, function(err, results) {
          var j, len, result;
          exceptions = {};
          for (j = 0, len = results.length; j < len; j++) {
            result = results[j];
            exceptions[result.pos] = result.data;
          }
          WordNet2.prototype.exceptions = exceptions;
          return callback();
        });
      };
      WordNet2.prototype.close = function() {
        this.nounIndex.close();
        this.verbIndex.close();
        this.adjIndex.close();
        this.advIndex.close();
        this.nounData.close();
        this.verbData.close();
        this.adjData.close();
        return this.advData.close();
      };
      unique = function(a) {
        var found;
        found = {};
        return a.filter(function(item) {
          if (found[item]) {
            return false;
          } else {
            return found[item] = true;
          }
        });
      };
      tokenDetach = function(string) {
        var detach, length, pos, ref, sense, word;
        ref = string.split("#"), word = ref[0], pos = ref[1], sense = ref[2];
        detach = [word];
        length = word.length;
        switch (pos) {
          case "n":
            if (word.endsWith("s")) {
              detach.push(word.substring(0, length - 1));
            }
            if (word.endsWith("ses")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("xes")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("zes")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("ches")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("shes")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("men")) {
              detach.push(word.substring(0, length - 3) + "man");
            }
            if (word.endsWith("ies")) {
              detach.push(word.substring(0, length - 3) + "y");
            }
            break;
          case "v":
            if (word.endsWith("s")) {
              detach.push(word.substring(0, length - 1));
            }
            if (word.endsWith("ies")) {
              detach.push(word.substring(0, length - 3) + "y");
            }
            if (word.endsWith("es")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("ed")) {
              detach.push(word.substring(0, length - 1));
            }
            if (word.endsWith("ed")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("ing")) {
              detach.push(word.substring(0, length - 3) + "e");
            }
            if (word.endsWith("ing")) {
              detach.push(word.substring(0, length - 3));
            }
            break;
          case "r":
            if (word.endsWith("er")) {
              detach.push(word.substring(0, length - 2));
            }
            if (word.endsWith("er")) {
              detach.push(word.substring(0, length - 1));
            }
            if (word.endsWith("est")) {
              detach.push(word.substring(0, length - 3));
            }
            if (word.endsWith("est")) {
              detach.push(word.substring(0, length - 2));
            }
        }
        return unique(detach);
      };
      _forms = function(wordnet, word, pos) {
        var colloc, exception, forms2, i, index, j, lword, ref, ref1, rtn, token, tokens;
        lword = word.toLowerCase();
        exception = (ref = wordnet.exceptions[pos]) != null ? ref[lword] : void 0;
        if (exception) {
          return [word].concat(exception);
        }
        tokens = word.split(/[ _]/g);
        if (tokens.length === 1) {
          return tokenDetach(tokens[0] + "#" + pos);
        }
        forms2 = tokens.map(function(token2) {
          return _forms(wordnet, token2, pos);
        });
        rtn = [];
        index = function() {
          var j2, len, results1;
          results1 = [];
          for (j2 = 0, len = tokens.length; j2 < len; j2++) {
            token = tokens[j2];
            results1.push(0);
          }
          return results1;
        }();
        while (true) {
          colloc = forms2[0][index[0]];
          for (i = j = 1, ref1 = tokens.length - 1; 1 <= ref1 ? j <= ref1 : j >= ref1; i = 1 <= ref1 ? ++j : --j) {
            colloc = colloc + "_" + forms2[i][index[i]];
          }
          rtn.push(colloc);
          i = 0;
          while (i < tokens.length) {
            index[i] = index[i] + 1;
            if (index[i] < forms2[i].length) {
              break;
            } else {
              index[i] = 0;
            }
            i = i + 1;
          }
          if (i >= tokens.length) {
            break;
          }
        }
        return rtn;
      };
      forms = function(wordnet, string) {
        var element, j, len, pos, ref, results1, rtn, sense, word;
        ref = string.split("#"), word = ref[0], pos = ref[1], sense = ref[2];
        rtn = _forms(wordnet, word, pos);
        results1 = [];
        for (j = 0, len = rtn.length; j < len; j++) {
          element = rtn[j];
          results1.push(element + "#" + pos);
        }
        return results1;
      };
      _validForms = function(wordnet, string, callback) {
        var eachFn, filteredResults, pos, possibleForms, reducer, ref, sense, word;
        ref = string.split("#"), word = ref[0], pos = ref[1], sense = ref[2];
        if (!pos) {
          reducer = function(previous, current, next) {
            return _validForms(wordnet, string + "#" + current, function(err, value) {
              if (value === void 0) {
                return next(null, previous);
              } else {
                return next(null, previous.concat(value));
              }
            });
          };
          return async.reduce(["n", "v", "a", "r"], [], reducer, function(err, result) {
            return callback(null, result);
          });
        } else {
          possibleForms = forms(wordnet, word + "#" + pos);
          filteredResults = [];
          eachFn = function(term, done) {
            return wordnet.lookup(term, function(err, data) {
              if (err != null) {
                return done(err);
              }
              if (data.length > 0) {
                filteredResults.push(term);
              }
              return done();
            });
          };
          return async.each(possibleForms, eachFn, function(err) {
            return callback(err, filteredResults);
          });
        }
      };
      _validFormsWithExceptions = function(wordnet, string, callback) {
        if (wordnet.exceptions === void 0) {
          return _loadExceptions(wordnet, function() {
            return _validFormsWithExceptions(wordnet, string, callback);
          });
        } else if (wordnet.exceptions === "pending") {
          return setImmediate(_validFormsWithExceptions, wordnet, string, callback);
        } else {
          return _validForms(wordnet, string, callback);
        }
      };
      WordNet2.prototype.validForms = function(string, callback) {
        var hit, query, wordnet;
        wordnet = this;
        if (this.cache) {
          query = "validForms:" + string;
          if (hit = wordnet.cache.get(query)) {
            if (callback.length === 1) {
              return callback.call(wordnet, hit);
            } else {
              return callback.call(wordnet, null, hit);
            }
          }
        }
        return _validFormsWithExceptions(this, string, function(err, result) {
          if (query) {
            wordnet.cache.set(query, result);
          }
          if (callback.length === 1) {
            return callback.call(wordnet, result);
          } else {
            return callback.call(wordnet, null, result);
          }
        });
      };
      WordNet2.prototype.validFormsAsync = function(string) {
        return new Promise2(function(_this) {
          return function(resolve, reject) {
            return _this.validForms(string, function(err, data) {
              if (err != null) {
                return reject(err);
              } else {
                return resolve(data);
              }
            });
          };
        }(this));
      };
      return WordNet2;
    }();
    module2.exports = WordNet;
  }
});
export default require_wordnet();
/*! Bundled license information:

async/lib/async.js:
  (*!
   * async
   * https://github.com/caolan/async
   *
   * Copyright 2010-2014 Caolan McMahon
   * Released under the MIT license
   *)

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2013-2015 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)

es6-shim/es6-shim.js:
  (*!
   * https://github.com/paulmillr/es6-shim
   * @license es6-shim Copyright 2013-2014 by Paul Miller (http://paulmillr.com)
   *   and contributors,  MIT License
   * es6-shim: v0.22.2
   * see https://github.com/paulmillr/es6-shim/blob/0.22.2/LICENSE
   * Details and documentation:
   * https://github.com/paulmillr/es6-shim/
   *)
*/
//# sourceMappingURL=node-wordnet.js.map
